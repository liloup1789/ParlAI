<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParlAI: Using Torch Generator Agent</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ParlAI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using Torch Generator Agent </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Authors</b>: Eric Smith</p>
<p><code><a class="el" href="../../d9/d5c/classparlai_1_1core_1_1torch__generator__agent_1_1TorchGeneratorAgent.html">parlai.core.torch_generator_agent.TorchGeneratorAgent</a></code> is an abstract parent class that provides functionality for building autoregressive generative models. Extending <code>TorchGeneratorAgent</code> requires your model conform to a strict interface, but then provides you rich functionality like beam search and sampling.</p>
<h2>Example Models</h2>
<p>Two major models in ParlAI inherit from <code>TorchGeneratorAgent</code>: <a class="el" href="../../d5/d9d/namespaceseq2seq.html">seq2seq</a> and transformer. You can try the transformer with the example below:</p>
<div class="fragment"><div class="line">python examples/train_model -m transformer/generator -t convai2 -mf /tmp/testtransformer \</div><div class="line">  --beam-size 5 -bs 16</div></div><!-- fragment --><h2>Creating a Model</h2>
<p>In order to write a generative model, your agent should extend <code>TorchGeneratorAgent</code>. This parent class implements <code>train_step</code> and <code>eval_step</code>, so you only need to implement your model and instantiate it through <code>build_model</code>. <code>TorchGeneratorAgent</code> will take care of many common generator features, such as forced decoding, beam search, n-gram beam blocking, top-k and top-p/nucleus sampling, etc.</p>
<p>Additionally, your model should implement the <code>TorchGeneratorModel</code> interface: see the tutorial below for an example of this.</p>
<h2>Tutorial</h2>
<p>This tutorial will walk you through creating a simple generative model, found at <code><a class="el" href="../../de/d7e/namespaceparlai_1_1agents_1_1examples_1_1seq2seq.html">parlai.agents.examples.seq2seq</a></code>, that consists of a 1-layer-LSTM encoder and decoder.</p>
<h3>Extending <code>TorchGeneratorAgent</code></h3>
<p>Creating a generative model in ParlAI consists of subclassing <code>TorchGeneratorAgent</code> and subclassing <code>TorchGeneratorModel</code>. A minimal subclass of <code>TorchGeneratorAgent</code> only needs to implement <code>build_model()</code>, but if you want to specify any command-line arguments, you'll need to add <code><a class="el" href="../../d3/d7d/namespaceparlai_1_1agents_1_1drqa_1_1config.html#a62fdd5554f1da6be0cba185271058320">add_cmdline_args()</a></code> as well. Our implementation below first adds flags for <code>TorchGeneratorAgent</code> and then adds a <code>--hidden-size</code> flag for the hidden dimension of the LSTMs of the encoder and decoder.</p>
<p>In <code>build_model()</code>, we instantiate our example model (defined below) by passing in the agent's dict (set by <code>TorchAgent</code>) and the hidden size. We add lines to optionally copy pre-existing token embeddings into the model's embedding table.</p>
<p>Altogether, our example agent is defined as follows:</p>
<div class="fragment"><div class="line">import parlai.core.torch_generator_agent as tga</div><div class="line"></div><div class="line"></div><div class="line">class Seq2seqAgent(tga.TorchGeneratorAgent):</div><div class="line"></div><div class="line">    @classmethod</div><div class="line">    def add_cmdline_args(cls, argparser):</div><div class="line">        super(Seq2seqAgent, cls).add_cmdline_args(argparser)</div><div class="line">        group = argparser.add_argument_group(&#39;Example TGA Agent&#39;)</div><div class="line">        group.add_argument(</div><div class="line">            &#39;-hid&#39;, &#39;--hidden-size&#39;, type=int, default=1024, help=&#39;Hidden size.&#39;</div><div class="line">        )</div><div class="line"></div><div class="line">    def build_model(self):</div><div class="line">        model = ExampleModel(self.dict, self.opt[&#39;hidden_size&#39;])</div><div class="line">        if self.opt[&#39;embedding_type&#39;] != &#39;random&#39;:</div><div class="line">            self._copy_embeddings(</div><div class="line">                model.embeddings.weight, self.opt[&#39;embedding_type&#39;]</div><div class="line">            )</div><div class="line">        return model</div></div><!-- fragment --><h3>Extending <code>TorchGeneratorModel</code></h3>
<p>We now subclass <code>TorchGeneratorModel</code> to create <code>ExampleModel</code>. We initialize this by first calling <code>super().__init__()</code> and passing in dictionary tokens for padding, start, end, and UNKs; we then create an embedding lookup table with <code>nn.Embedding</code> and instantiate the encoder and decoder, described in the following sections.</p>
<div class="fragment"><div class="line">import torch.nn as nn</div><div class="line">import torch.nn.functional as F</div><div class="line"></div><div class="line">class ExampleModel(tga.TorchGeneratorModel):</div><div class="line"></div><div class="line">    def __init__(self, dictionary, esz=256, hidden_size=1024):</div><div class="line">        super().__init__(</div><div class="line">            padding_idx=dictionary[dictionary.null_token],</div><div class="line">            start_idx=dictionary[dictionary.start_token],</div><div class="line">            end_idx=dictionary[dictionary.end_token],</div><div class="line">            unknown_idx=dictionary[dictionary.unk_token],</div><div class="line">        )</div><div class="line">        self.embeddings = nn.Embedding(len(dictionary), esz)</div><div class="line">        self.encoder = Encoder(self.embeddings, hidden_size)</div><div class="line">        self.decoder = Decoder(self.embeddings, hidden_size)</div></div><!-- fragment --><p>We next define a function to project the output of the decoder back into the token space:</p>
<div class="fragment"><div class="line">def output(self, decoder_output):</div><div class="line">    return F.linear(decoder_output, self.embeddings.weight)</div></div><!-- fragment --><p>Lastly, we define two functions to reindex the latent states of the encoder and decoder. For the encoder, the indices that we pass in index the samples in the batch, and for the decoder, the indices index the candidates that we want to retain for the next step of decoding (for instance, in beam search). We reindex the encoder at the very beginning of beam search and when ranking candidates during eval, and we reindex the decoder after each step of decoding. Since our encoder and decoder both are based on LSTMs, these encoder/decoder states are the hidden and cell states: </p><div class="fragment"><div class="line">def reorder_encoder_states(self, encoder_states, indices):</div><div class="line">    h, c = encoder_states</div><div class="line">    return h[:, indices, :], c[:, indices, :]</div><div class="line"></div><div class="line">def reorder_decoder_incremental_state(self, incr_state, indices):</div><div class="line">    h, c = incr_state</div><div class="line">    return h[:, indices, :], c[:, indices, :]</div></div><!-- fragment --><h3>Creating the encoder</h3>
<p>The encoder is straightfoward: it contains an embedding layer and an LSTM, and a forward pass through the encoder consists of passing the sequences of input tokens through both of them sequentially. The final hidden state is returned.</p>
<div class="fragment"><div class="line">class Encoder(nn.Module):</div><div class="line"></div><div class="line">    def __init__(self, embeddings, hidden_size):</div><div class="line">        super().__init__()</div><div class="line">        _vocab_size, esz = embeddings.weight.shape</div><div class="line">        self.embeddings = embeddings</div><div class="line">        self.lstm = nn.LSTM(</div><div class="line">            input_size=esz, hidden_size=hidden_size, num_layers=1, batch_first=True</div><div class="line">        )</div><div class="line"></div><div class="line">    def forward(self, input_tokens):</div><div class="line">        embedded = self.embeddings(input_tokens)</div><div class="line">        _output, hidden = self.lstm(embedded)</div><div class="line">        return hidden</div></div><!-- fragment --><h3>Creating the decoder</h3>
<p>The decoder is initialized in the same way as the encoder, but now the forward pass reflects the fact that the input tokens need to be passed through the embedder and LSTM one token at a time rather than all at once. If this is the first pass through the decoder, we pass a tuple <code>encoder_state</code> to the LSTM that consists of the initial hidden and cell state, as taken from the output of the encoder. If this is a subsequent pass through the decoder, the LSTM will have given us the current values of the hidden and cell states, so we pass that back in to the LSTM, after potentially having reindexed the states with <code>ExampleModel().reorder_decoder_incremental_state()</code>.</p>
<div class="fragment"><div class="line">class Decoder(nn.Module):</div><div class="line"></div><div class="line">    def __init__(self, embeddings, hidden_size):</div><div class="line">        super().__init__()</div><div class="line">        _vocab_size, self.esz = embeddings.weight.shape</div><div class="line">        self.embeddings = embeddings</div><div class="line">        self.lstm = nn.LSTM(</div><div class="line">            input_size=self.esz, hidden_size=hidden_size, num_layers=1, batch_first=True</div><div class="line">        )</div><div class="line"></div><div class="line">    def forward(self, input, encoder_state, incr_state=None):</div><div class="line">        embedded = self.embeddings(input)</div><div class="line">        if incr_state is None:</div><div class="line">            state = encoder_state</div><div class="line">        else:</div><div class="line">            state = incr_state</div><div class="line">        output, incr_state = self.lstm(embedded, state)</div><div class="line">        return output, incr_state</div></div><!-- fragment --><h3>Training</h3>
<p>The full code for the agent can be seen <a href="https://github.com/facebookresearch/ParlAI/tree/master/parlai/agents/examples/seq2seq.py">here</a>. To call training:</p>
<div class="fragment"><div class="line">python examples/train_model.py -m examples/seq2seq \</div><div class="line">    -mf /tmp/example_model \</div><div class="line">    -t convai2 -bs 32 -eps 2 --truncate 128</div></div><!-- fragment --><p>You should get a perplexity of around 140 and a token accuracy of around 28% on the ConvAI2 validation/test set. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
