\hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils}{}\section{parlai.\+agents.\+drqa.\+utils Namespace Reference}
\label{namespaceparlai_1_1agents_1_1drqa_1_1utils}\index{parlai.\+agents.\+drqa.\+utils@{parlai.\+agents.\+drqa.\+utils}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classparlai_1_1agents_1_1drqa_1_1utils_1_1AverageMeter}{Average\+Meter}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a125ab4e64306060e9ecaa3999f7be6b6}{normalize\+\_\+text} (text)
\item 
def \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_aa92d9906125210574825a20c75c199c8}{load\+\_\+embeddings} (opt, word\+\_\+dict)
\item 
def \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a14201349d4a16b48aa7929cfdbf10ebd}{build\+\_\+feature\+\_\+dict} (opt)
\item 
def \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a5c76cc39e3014c7bcf9199d566dbdc0f}{vectorize} (opt, ex, word\+\_\+dict, feature\+\_\+dict)
\item 
def \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_aca22dd97c5b6dcda2a7479c1cb22ef1e}{batchify} (batch, null=0, cuda=False)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils_aca22dd97c5b6dcda2a7479c1cb22ef1e}\label{namespaceparlai_1_1agents_1_1drqa_1_1utils_aca22dd97c5b6dcda2a7479c1cb22ef1e}} 
\index{parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}!batchify@{batchify}}
\index{batchify@{batchify}!parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}}
\subsubsection{\texorpdfstring{batchify()}{batchify()}}
{\footnotesize\ttfamily def parlai.\+agents.\+drqa.\+utils.\+batchify (\begin{DoxyParamCaption}\item[{}]{batch,  }\item[{}]{null = {\ttfamily 0},  }\item[{}]{cuda = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Collate inputs into batches.
\end{DoxyVerb}
 

Definition at line 124 of file utils.\+py.


\begin{DoxyCode}
124 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_aca22dd97c5b6dcda2a7479c1cb22ef1e}{batchify}(batch, null=0, cuda=False):
125     \textcolor{stringliteral}{"""}
126 \textcolor{stringliteral}{    Collate inputs into batches.}
127 \textcolor{stringliteral}{    """}
128     NUM\_INPUTS = 3
129     NUM\_TARGETS = 2
130     NUM\_EXTRA = 2
131 
132     \textcolor{comment}{# Get elements}
133     docs = [ex[0] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch]
134     features = [ex[1] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch]
135     questions = [ex[2] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch]
136     text = [ex[-2] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch]
137     spans = [ex[-1] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch]
138 
139     \textcolor{comment}{# Batch documents and features}
140     max\_length = max([d.size(0) \textcolor{keywordflow}{for} d \textcolor{keywordflow}{in} docs])
141     x1 = torch.LongTensor(len(docs), max\_length).fill\_(null)
142     x1\_mask = torch.ByteTensor(len(docs), max\_length).fill\_(1)
143     x1\_f = torch.zeros(len(docs), max\_length, features[0].size(1))
144     \textcolor{keywordflow}{for} i, d \textcolor{keywordflow}{in} enumerate(docs):
145         x1[i, : d.size(0)].copy\_(d)
146         x1\_mask[i, : d.size(0)].fill\_(0)
147         x1\_f[i, : d.size(0)].copy\_(features[i])
148 
149     \textcolor{comment}{# Batch questions}
150     max\_length = max([q.size(0) \textcolor{keywordflow}{for} q \textcolor{keywordflow}{in} questions])
151     x2 = torch.LongTensor(len(questions), max\_length).fill\_(null)
152     x2\_mask = torch.ByteTensor(len(questions), max\_length).fill\_(1)
153     \textcolor{keywordflow}{for} i, q \textcolor{keywordflow}{in} enumerate(questions):
154         x2[i, : q.size(0)].copy\_(q)
155         x2\_mask[i, : q.size(0)].fill\_(0)
156 
157     \textcolor{comment}{# Pin memory if cuda}
158     \textcolor{keywordflow}{if} cuda:
159         x1 = x1.pin\_memory()
160         x1\_f = x1\_f.pin\_memory()
161         x1\_mask = x1\_mask.pin\_memory()
162         x2 = x2.pin\_memory()
163         x2\_mask = x2\_mask.pin\_memory()
164 
165     \textcolor{comment}{# Maybe return without targets}
166     \textcolor{keywordflow}{if} len(batch[0]) == NUM\_INPUTS + NUM\_EXTRA:
167         \textcolor{keywordflow}{return} x1, x1\_f, x1\_mask, x2, x2\_mask, text, spans
168 
169     \textcolor{comment}{# ...Otherwise add targets}
170     \textcolor{keywordflow}{elif} len(batch[0]) == NUM\_INPUTS + NUM\_EXTRA + NUM\_TARGETS:
171         y\_s = torch.cat([ex[3] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch])
172         y\_e = torch.cat([ex[4] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} batch])
173         \textcolor{keywordflow}{return} x1, x1\_f, x1\_mask, x2, x2\_mask, y\_s, y\_e, text, spans
174 
175     \textcolor{comment}{# ...Otherwise wrong number of inputs}
176     \textcolor{keywordflow}{raise} RuntimeError(\textcolor{stringliteral}{'Wrong number of inputs per batch'})
177 
178 
179 \textcolor{comment}{# ------------------------------------------------------------------------------}
180 \textcolor{comment}{# General logging utilities.}
181 \textcolor{comment}{# ------------------------------------------------------------------------------}
182 
183 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils_a14201349d4a16b48aa7929cfdbf10ebd}\label{namespaceparlai_1_1agents_1_1drqa_1_1utils_a14201349d4a16b48aa7929cfdbf10ebd}} 
\index{parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}!build\+\_\+feature\+\_\+dict@{build\+\_\+feature\+\_\+dict}}
\index{build\+\_\+feature\+\_\+dict@{build\+\_\+feature\+\_\+dict}!parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}}
\subsubsection{\texorpdfstring{build\+\_\+feature\+\_\+dict()}{build\_feature\_dict()}}
{\footnotesize\ttfamily def parlai.\+agents.\+drqa.\+utils.\+build\+\_\+feature\+\_\+dict (\begin{DoxyParamCaption}\item[{}]{opt }\end{DoxyParamCaption})}

\begin{DoxyVerb}Make mapping of feature option to feature index.
\end{DoxyVerb}
 

Definition at line 48 of file utils.\+py.


\begin{DoxyCode}
48 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a14201349d4a16b48aa7929cfdbf10ebd}{build\_feature\_dict}(opt):
49     \textcolor{stringliteral}{"""}
50 \textcolor{stringliteral}{    Make mapping of feature option to feature index.}
51 \textcolor{stringliteral}{    """}
52     feature\_dict = \{\}
53     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_in\_question'}]:
54         feature\_dict[\textcolor{stringliteral}{'in\_question'}] = len(feature\_dict)
55         feature\_dict[\textcolor{stringliteral}{'in\_question\_uncased'}] = len(feature\_dict)
56     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_tf'}]:
57         feature\_dict[\textcolor{stringliteral}{'tf'}] = len(feature\_dict)
58     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_time'}] > 0:
59         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(opt[\textcolor{stringliteral}{'use\_time'}] - 1):
60             feature\_dict[\textcolor{stringliteral}{'time=T%d'} % (i + 1)] = len(feature\_dict)
61         feature\_dict[\textcolor{stringliteral}{'time>=T%d'} % opt[\textcolor{stringliteral}{'use\_time'}]] = len(feature\_dict)
62     \textcolor{keywordflow}{return} feature\_dict
63 
64 
65 \textcolor{comment}{# ------------------------------------------------------------------------------}
66 \textcolor{comment}{# Torchified input utilities.}
67 \textcolor{comment}{# ------------------------------------------------------------------------------}
68 
69 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils_aa92d9906125210574825a20c75c199c8}\label{namespaceparlai_1_1agents_1_1drqa_1_1utils_aa92d9906125210574825a20c75c199c8}} 
\index{parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}!load\+\_\+embeddings@{load\+\_\+embeddings}}
\index{load\+\_\+embeddings@{load\+\_\+embeddings}!parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}}
\subsubsection{\texorpdfstring{load\+\_\+embeddings()}{load\_embeddings()}}
{\footnotesize\ttfamily def parlai.\+agents.\+drqa.\+utils.\+load\+\_\+embeddings (\begin{DoxyParamCaption}\item[{}]{opt,  }\item[{}]{word\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Initialize embeddings from file of pretrained vectors.
\end{DoxyVerb}
 

Definition at line 22 of file utils.\+py.


\begin{DoxyCode}
22 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_aa92d9906125210574825a20c75c199c8}{load\_embeddings}(opt, word\_dict):
23     \textcolor{stringliteral}{"""}
24 \textcolor{stringliteral}{    Initialize embeddings from file of pretrained vectors.}
25 \textcolor{stringliteral}{    """}
26     embeddings = torch.Tensor(len(word\_dict), opt[\textcolor{stringliteral}{'embedding\_dim'}])
27     embeddings.normal\_(0, 1)
28     opt[\textcolor{stringliteral}{'embedding\_file'}] = \hyperlink{namespaceparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_a5fbd3301b67f00d6d146fb01c7cd7626}{modelzoo\_path}(opt.get(\textcolor{stringliteral}{'datapath'}), opt[\textcolor{stringliteral}{'embedding\_file'}])
29     \textcolor{comment}{# Fill in embeddings}
30     \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} opt.get(\textcolor{stringliteral}{'embedding\_file'}):
31         \textcolor{keywordflow}{raise} RuntimeError(\textcolor{stringliteral}{'Tried to load embeddings with no embedding file.'})
32     with open(opt[\textcolor{stringliteral}{'embedding\_file'}]) \textcolor{keyword}{as} f:
33         \textcolor{keywordflow}{for} line \textcolor{keywordflow}{in} f:
34             parsed = line.rstrip().split(\textcolor{stringliteral}{' '})
35             \textcolor{keywordflow}{if} len(parsed) > 2:
36                 \textcolor{keyword}{assert} len(parsed) == opt[\textcolor{stringliteral}{'embedding\_dim'}] + 1
37                 w = \hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a125ab4e64306060e9ecaa3999f7be6b6}{normalize\_text}(parsed[0])
38                 \textcolor{keywordflow}{if} w \textcolor{keywordflow}{in} word\_dict:
39                     vec = torch.Tensor([\hyperlink{namespaceprojects_1_1controllable__dialogue_1_1make__control__dataset_aa2b7207688c641dbc094ab44eca27113}{float}(i) \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} parsed[1:]])
40                     embeddings[word\_dict[w]].copy\_(vec)
41 
42     \textcolor{comment}{# Zero NULL token}
43     embeddings[word\_dict[\textcolor{stringliteral}{'\_\_NULL\_\_'}]].fill\_(0)
44 
45     \textcolor{keywordflow}{return} embeddings
46 
47 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils_a125ab4e64306060e9ecaa3999f7be6b6}\label{namespaceparlai_1_1agents_1_1drqa_1_1utils_a125ab4e64306060e9ecaa3999f7be6b6}} 
\index{parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}!normalize\+\_\+text@{normalize\+\_\+text}}
\index{normalize\+\_\+text@{normalize\+\_\+text}!parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}}
\subsubsection{\texorpdfstring{normalize\+\_\+text()}{normalize\_text()}}
{\footnotesize\ttfamily def parlai.\+agents.\+drqa.\+utils.\+normalize\+\_\+text (\begin{DoxyParamCaption}\item[{}]{text }\end{DoxyParamCaption})}



Definition at line 18 of file utils.\+py.


\begin{DoxyCode}
18 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a125ab4e64306060e9ecaa3999f7be6b6}{normalize\_text}(text):
19     \textcolor{keywordflow}{return} unicodedata.normalize(\textcolor{stringliteral}{'NFD'}, text)
20 
21 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1agents_1_1drqa_1_1utils_a5c76cc39e3014c7bcf9199d566dbdc0f}\label{namespaceparlai_1_1agents_1_1drqa_1_1utils_a5c76cc39e3014c7bcf9199d566dbdc0f}} 
\index{parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}!vectorize@{vectorize}}
\index{vectorize@{vectorize}!parlai\+::agents\+::drqa\+::utils@{parlai\+::agents\+::drqa\+::utils}}
\subsubsection{\texorpdfstring{vectorize()}{vectorize()}}
{\footnotesize\ttfamily def parlai.\+agents.\+drqa.\+utils.\+vectorize (\begin{DoxyParamCaption}\item[{}]{opt,  }\item[{}]{ex,  }\item[{}]{word\+\_\+dict,  }\item[{}]{feature\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Turn tokenized text inputs into feature vectors.
\end{DoxyVerb}
 

Definition at line 70 of file utils.\+py.


\begin{DoxyCode}
70 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1agents_1_1drqa_1_1utils_a5c76cc39e3014c7bcf9199d566dbdc0f}{vectorize}(opt, ex, word\_dict, feature\_dict):
71     \textcolor{stringliteral}{"""}
72 \textcolor{stringliteral}{    Turn tokenized text inputs into feature vectors.}
73 \textcolor{stringliteral}{    """}
74     \textcolor{comment}{# Index words}
75     document = torch.LongTensor([word\_dict[w] \textcolor{keywordflow}{for} w \textcolor{keywordflow}{in} ex[\textcolor{stringliteral}{'document'}]])
76     question = torch.LongTensor([word\_dict[w] \textcolor{keywordflow}{for} w \textcolor{keywordflow}{in} ex[\textcolor{stringliteral}{'question'}]])
77 
78     \textcolor{comment}{# Create extra features vector}
79     features = torch.zeros(len(ex[\textcolor{stringliteral}{'document'}]), len(feature\_dict))
80 
81     \textcolor{comment}{# f\_\{exact\_match\}}
82     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_in\_question'}]:
83         q\_words\_cased = set([w \textcolor{keywordflow}{for} w \textcolor{keywordflow}{in} ex[\textcolor{stringliteral}{'question'}]])
84         q\_words\_uncased = set([w.lower() \textcolor{keywordflow}{for} w \textcolor{keywordflow}{in} ex[\textcolor{stringliteral}{'question'}]])
85         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(len(ex[\textcolor{stringliteral}{'document'}])):
86             \textcolor{keywordflow}{if} ex[\textcolor{stringliteral}{'document'}][i] \textcolor{keywordflow}{in} q\_words\_cased:
87                 features[i][feature\_dict[\textcolor{stringliteral}{'in\_question'}]] = 1.0
88             \textcolor{keywordflow}{if} ex[\textcolor{stringliteral}{'document'}][i].lower() \textcolor{keywordflow}{in} q\_words\_uncased:
89                 features[i][feature\_dict[\textcolor{stringliteral}{'in\_question\_uncased'}]] = 1.0
90 
91     \textcolor{comment}{# f\_\{tf\}}
92     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_tf'}]:
93         counter = Counter([w.lower() \textcolor{keywordflow}{for} w \textcolor{keywordflow}{in} ex[\textcolor{stringliteral}{'document'}]])
94         l = len(ex[\textcolor{stringliteral}{'document'}])
95         \textcolor{keywordflow}{for} i, w \textcolor{keywordflow}{in} enumerate(ex[\textcolor{stringliteral}{'document'}]):
96             features[i][feature\_dict[\textcolor{stringliteral}{'tf'}]] = counter[w.lower()] * 1.0 / l
97 
98     \textcolor{keywordflow}{if} opt[\textcolor{stringliteral}{'use\_time'}] > 0:
99         \textcolor{comment}{# Counting from the end, each (full-stop terminated) sentence gets}
100         \textcolor{comment}{# its own time identitfier.}
101         sent\_idx = 0
102 
103         \textcolor{keyword}{def }\_full\_stop(w):
104             \textcolor{keywordflow}{return} w \textcolor{keywordflow}{in} \{\textcolor{stringliteral}{'.'}, \textcolor{stringliteral}{'?'}, \textcolor{stringliteral}{'!'}\}
105 
106         \textcolor{keywordflow}{for} i, w \textcolor{keywordflow}{in} reversed(list(enumerate(ex[\textcolor{stringliteral}{'document'}]))):
107             sent\_idx = sent\_idx + 1 \textcolor{keywordflow}{if} \_full\_stop(w) \textcolor{keywordflow}{else} max(sent\_idx, 1)
108             \textcolor{keywordflow}{if} sent\_idx < opt[\textcolor{stringliteral}{'use\_time'}]:
109                 features[i][feature\_dict[\textcolor{stringliteral}{'time=T%d'} % sent\_idx]] = 1.0
110             \textcolor{keywordflow}{else}:
111                 features[i][feature\_dict[\textcolor{stringliteral}{'time>=T%d'} % opt[\textcolor{stringliteral}{'use\_time'}]]] = 1.0
112 
113     \textcolor{comment}{# Maybe return without target}
114     \textcolor{keywordflow}{if} ex[\textcolor{stringliteral}{'target'}] \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
115         \textcolor{keywordflow}{return} document, features, question
116 
117     \textcolor{comment}{# ...or with target}
118     start = torch.LongTensor([ex[\textcolor{stringliteral}{'target'}][0]])
119     end = torch.LongTensor([ex[\textcolor{stringliteral}{'target'}][1]])
120 
121     \textcolor{keywordflow}{return} document, features, question, start, end
122 
123 
\end{DoxyCode}
