\hypertarget{namespaceparlai_1_1core_1_1build__data}{}\section{parlai.\+core.\+build\+\_\+data Namespace Reference}
\label{namespaceparlai_1_1core_1_1build__data}\index{parlai.\+core.\+build\+\_\+data@{parlai.\+core.\+build\+\_\+data}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classparlai_1_1core_1_1build__data_1_1DownloadableFile}{Downloadable\+File}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}{built} (path, version\+\_\+string=None)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a2527e6d29b0ccb7b841182890ac36a59}{mark\+\_\+done} (path, version\+\_\+string=None)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ab74f0e428f05e5d91fa93c8afb367622}{download} (url, path, fname, redownload=False)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a6ce042fedd4194bd016845bbe7a8facf}{make\+\_\+dir} (path)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a1678b8a042eeb9d9c8e9de08f52e496b}{move} (path1, path2)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a24ab3b7e68e41adf774df058d330ff33}{remove\+\_\+dir} (path)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a4d33f97932682a8513904022d852f3cf}{untar} (path, fname, delete\+Tar=True)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_a7cbfdf246ca40dc3ed9f8613deb14a00}{unzip} (path, fname, delete\+Zip=True)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_adc4feba864e2a0d0663cdf6bf84afaf6}{cat} (file1, file2, outfile, delete\+Files=True)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ac9224da5c4e4ce9d1f4ab05e837c1f45}{download\+\_\+from\+\_\+google\+\_\+drive} (gd\+\_\+id, destination)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ad2fe6222094caae59f304931aee0952a}{get\+\_\+model\+\_\+dir} (datapath)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ab697f23f05d3e36d7979fe5e0ed7911e}{download\+\_\+models} (opt, fnames, model\+\_\+folder, version=\textquotesingle{}v1.\+0\textquotesingle{}, path=\textquotesingle{}aws\textquotesingle{}, use\+\_\+model\+\_\+type=False)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ad06e9e38ca85db9c4a676ccd9ae41649}{modelzoo\+\_\+path} (datapath, path)
\item 
def \hyperlink{namespaceparlai_1_1core_1_1build__data_ae259aeb321a77560fbcd23028178c897}{download\+\_\+multiprocess} (urls, path, num\+\_\+processes=32, chunk\+\_\+size=100, dest\+\_\+filenames=None, error\+\_\+path=None)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}\label{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!built@{built}}
\index{built@{built}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{built()}{built()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+built (\begin{DoxyParamCaption}\item[{}]{path,  }\item[{}]{version\+\_\+string = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if '.built' flag has been set for that task.

If a version_string is provided, this has to match, or the version is regarded as
not built.
\end{DoxyVerb}
 

Definition at line 110 of file build\+\_\+data.\+py.


\begin{DoxyCode}
110 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}{built}(path, version\_string=None):
111     \textcolor{stringliteral}{"""}
112 \textcolor{stringliteral}{    Check if '.built' flag has been set for that task.}
113 \textcolor{stringliteral}{}
114 \textcolor{stringliteral}{    If a version\_string is provided, this has to match, or the version is regarded as}
115 \textcolor{stringliteral}{    not built.}
116 \textcolor{stringliteral}{    """}
117     \textcolor{keywordflow}{if} version\_string:
118         print(\textcolor{stringliteral}{"VERSION STRING ON"})
119         fname = os.path.join(path, \textcolor{stringliteral}{'.built'})
120         print(fname)
121         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} os.path.isfile(fname):
122             \textcolor{keywordflow}{return} \textcolor{keyword}{False}
123         \textcolor{keywordflow}{else}:
124             with open(fname, \textcolor{stringliteral}{'r') as read:}
125 \textcolor{stringliteral}{                text = read.read().split('\(\backslash\)n'})
126             \textcolor{keywordflow}{return} len(text) > 1 \textcolor{keywordflow}{and} text[1] == version\_string
127     \textcolor{keywordflow}{else}:
128         print(\textcolor{stringliteral}{"VERSION STRING OFF"})
129         \textcolor{keywordflow}{return} os.path.isfile(os.path.join(path, \textcolor{stringliteral}{'.built'}))
130 
131 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_adc4feba864e2a0d0663cdf6bf84afaf6}\label{namespaceparlai_1_1core_1_1build__data_adc4feba864e2a0d0663cdf6bf84afaf6}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!cat@{cat}}
\index{cat@{cat}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{cat()}{cat()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+cat (\begin{DoxyParamCaption}\item[{}]{file1,  }\item[{}]{file2,  }\item[{}]{outfile,  }\item[{}]{delete\+Files = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Concatenate two files to an outfile, possibly deleting the originals.
\end{DoxyVerb}
 

Definition at line 303 of file build\+\_\+data.\+py.


\begin{DoxyCode}
303 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_adc4feba864e2a0d0663cdf6bf84afaf6}{cat}(file1, file2, outfile, deleteFiles=True):
304     \textcolor{stringliteral}{"""}
305 \textcolor{stringliteral}{    Concatenate two files to an outfile, possibly deleting the originals.}
306 \textcolor{stringliteral}{    """}
307     with open(outfile, \textcolor{stringliteral}{'wb'}) \textcolor{keyword}{as} wfd:
308         \textcolor{keywordflow}{for} f \textcolor{keywordflow}{in} [file1, file2]:
309             with open(f, \textcolor{stringliteral}{'rb'}) \textcolor{keyword}{as} fd:
310                 shutil.copyfileobj(fd, wfd, 1024 * 1024 * 10)
311                 \textcolor{comment}{# 10MB per writing chunk to avoid reading big file into memory.}
312     \textcolor{keywordflow}{if} deleteFiles:
313         os.remove(file1)
314         os.remove(file2)
315 
316 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ab74f0e428f05e5d91fa93c8afb367622}\label{namespaceparlai_1_1core_1_1build__data_ab74f0e428f05e5d91fa93c8afb367622}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!download@{download}}
\index{download@{download}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{download()}{download()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+download (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{path,  }\item[{}]{fname,  }\item[{}]{redownload = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Download file using `requests`.

If ``redownload`` is set to false, then will not download tar file again if it is
present (default ``True``).
\end{DoxyVerb}
 

Definition at line 151 of file build\+\_\+data.\+py.


\begin{DoxyCode}
151 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_ab74f0e428f05e5d91fa93c8afb367622}{download}(url, path, fname, redownload=False):
152     \textcolor{stringliteral}{"""}
153 \textcolor{stringliteral}{    Download file using `requests`.}
154 \textcolor{stringliteral}{}
155 \textcolor{stringliteral}{    If ``redownload`` is set to false, then will not download tar file again if it is}
156 \textcolor{stringliteral}{    present (default ``True``).}
157 \textcolor{stringliteral}{    """}
158     outfile = os.path.join(path, fname)
159     download = \textcolor{keywordflow}{not} os.path.isfile(outfile) \textcolor{keywordflow}{or} redownload
160     print(\textcolor{stringliteral}{"[ downloading: "} + url + \textcolor{stringliteral}{" to "} + outfile + \textcolor{stringliteral}{" ]"})
161     retry = 5
162     exp\_backoff = [2 ** r \textcolor{keywordflow}{for} r \textcolor{keywordflow}{in} reversed(range(retry))]
163 
164     pbar = tqdm.tqdm(unit=\textcolor{stringliteral}{'B'}, unit\_scale=\textcolor{keyword}{True}, desc=\textcolor{stringliteral}{'Downloading \{\}'}.\hyperlink{namespaceparlai_1_1chat__service_1_1services_1_1messenger_1_1shared__utils_a32e2e2022b824fbaf80c747160b52a76}{format}(fname))
165 
166     \textcolor{keywordflow}{while} download \textcolor{keywordflow}{and} retry >= 0:
167         resume\_file = outfile + \textcolor{stringliteral}{'.part'}
168         resume = os.path.isfile(resume\_file)
169         \textcolor{keywordflow}{if} resume:
170             resume\_pos = os.path.getsize(resume\_file)
171             mode = \textcolor{stringliteral}{'ab'}
172         \textcolor{keywordflow}{else}:
173             resume\_pos = 0
174             mode = \textcolor{stringliteral}{'wb'}
175         response = \textcolor{keywordtype}{None}
176 
177         with requests.Session() \textcolor{keyword}{as} session:
178             \textcolor{keywordflow}{try}:
179                 header = (
180                     \{\textcolor{stringliteral}{'Range'}: \textcolor{stringliteral}{'bytes=%d-'} % resume\_pos, \textcolor{stringliteral}{'Accept-Encoding'}: \textcolor{stringliteral}{'identity'}\}
181                     \textcolor{keywordflow}{if} resume
182                     \textcolor{keywordflow}{else} \{\}
183                 )
184                 response = session.get(url, stream=\textcolor{keyword}{True}, timeout=5, headers=header)
185 
186                 \textcolor{comment}{# negative reply could be 'none' or just missing}
187                 \textcolor{keywordflow}{if} resume \textcolor{keywordflow}{and} response.headers.get(\textcolor{stringliteral}{'Accept-Ranges'}, \textcolor{stringliteral}{'none'}) == \textcolor{stringliteral}{'none'}:
188                     resume\_pos = 0
189                     mode = \textcolor{stringliteral}{'wb'}
190 
191                 CHUNK\_SIZE = 32768
192                 total\_size = \hyperlink{namespacelanguage__model_1_1eval__ppl_a7d12ee00479673c5c8d1f6d01faa272a}{int}(response.headers.get(\textcolor{stringliteral}{'Content-Length'}, -1))
193                 \textcolor{comment}{# server returns remaining size if resuming, so adjust total}
194                 total\_size += resume\_pos
195                 pbar.total = total\_size
196                 done = resume\_pos
197 
198                 with open(resume\_file, mode) \textcolor{keyword}{as} f:
199                     \textcolor{keywordflow}{for} chunk \textcolor{keywordflow}{in} response.iter\_content(CHUNK\_SIZE):
200                         \textcolor{keywordflow}{if} chunk:  \textcolor{comment}{# filter out keep-alive new chunks}
201                             f.write(chunk)
202                         \textcolor{keywordflow}{if} total\_size > 0:
203                             done += len(chunk)
204                             \textcolor{keywordflow}{if} total\_size < done:
205                                 \textcolor{comment}{# don't freak out if content-length was too small}
206                                 total\_size = done
207                                 pbar.total = total\_size
208                             pbar.update(len(chunk))
209                     \textcolor{keywordflow}{break}
210             \textcolor{keywordflow}{except} requests.exceptions.ConnectionError:
211                 retry -= 1
212                 pbar.clear()
213                 \textcolor{keywordflow}{if} retry >= 0:
214                     print(\textcolor{stringliteral}{'Connection error, retrying. (%d retries left)'} % retry)
215                     time.sleep(exp\_backoff[retry])
216                 \textcolor{keywordflow}{else}:
217                     print(\textcolor{stringliteral}{'Retried too many times, stopped retrying.'})
218             \textcolor{keywordflow}{finally}:
219                 \textcolor{keywordflow}{if} response:
220                     response.close()
221     \textcolor{keywordflow}{if} retry < 0:
222         \textcolor{keywordflow}{raise} RuntimeWarning(\textcolor{stringliteral}{'Connection broken too many times. Stopped retrying.'})
223 
224     \textcolor{keywordflow}{if} download \textcolor{keywordflow}{and} retry > 0:
225         pbar.update(done - pbar.n)
226         \textcolor{keywordflow}{if} done < total\_size:
227             \textcolor{keywordflow}{raise} RuntimeWarning(
228                 \textcolor{stringliteral}{'Received less data than specified in '}
229                 + \textcolor{stringliteral}{'Content-Length header for '}
230                 + url
231                 + \textcolor{stringliteral}{'.'}
232                 + \textcolor{stringliteral}{' There may be a download problem.'}
233             )
234         \hyperlink{namespaceparlai_1_1core_1_1build__data_a1678b8a042eeb9d9c8e9de08f52e496b}{move}(resume\_file, outfile)
235 
236     pbar.close()
237 
238 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ac9224da5c4e4ce9d1f4ab05e837c1f45}\label{namespaceparlai_1_1core_1_1build__data_ac9224da5c4e4ce9d1f4ab05e837c1f45}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!download\+\_\+from\+\_\+google\+\_\+drive@{download\+\_\+from\+\_\+google\+\_\+drive}}
\index{download\+\_\+from\+\_\+google\+\_\+drive@{download\+\_\+from\+\_\+google\+\_\+drive}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{download\+\_\+from\+\_\+google\+\_\+drive()}{download\_from\_google\_drive()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+download\+\_\+from\+\_\+google\+\_\+drive (\begin{DoxyParamCaption}\item[{}]{gd\+\_\+id,  }\item[{}]{destination }\end{DoxyParamCaption})}

\begin{DoxyVerb}Use the requests package to download a file from Google Drive.
\end{DoxyVerb}
 

Definition at line 324 of file build\+\_\+data.\+py.


\begin{DoxyCode}
324 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_ac9224da5c4e4ce9d1f4ab05e837c1f45}{download\_from\_google\_drive}(gd\_id, destination):
325     \textcolor{stringliteral}{"""}
326 \textcolor{stringliteral}{    Use the requests package to download a file from Google Drive.}
327 \textcolor{stringliteral}{    """}
328     URL = \textcolor{stringliteral}{'https://docs.google.com/uc?export=download'}
329 
330     with requests.Session() \textcolor{keyword}{as} session:
331         response = session.get(URL, params=\{\textcolor{stringliteral}{'id'}: gd\_id\}, stream=\textcolor{keyword}{True})
332         token = \_get\_confirm\_token(response)
333 
334         \textcolor{keywordflow}{if} token:
335             response.close()
336             params = \{\textcolor{stringliteral}{'id'}: gd\_id, \textcolor{stringliteral}{'confirm'}: token\}
337             response = session.get(URL, params=params, stream=\textcolor{keyword}{True})
338 
339         CHUNK\_SIZE = 32768
340         with open(destination, \textcolor{stringliteral}{'wb'}) \textcolor{keyword}{as} f:
341             \textcolor{keywordflow}{for} chunk \textcolor{keywordflow}{in} response.iter\_content(CHUNK\_SIZE):
342                 \textcolor{keywordflow}{if} chunk:  \textcolor{comment}{# filter out keep-alive new chunks}
343                     f.write(chunk)
344         response.close()
345 
346 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ab697f23f05d3e36d7979fe5e0ed7911e}\label{namespaceparlai_1_1core_1_1build__data_ab697f23f05d3e36d7979fe5e0ed7911e}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!download\+\_\+models@{download\+\_\+models}}
\index{download\+\_\+models@{download\+\_\+models}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{download\+\_\+models()}{download\_models()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+download\+\_\+models (\begin{DoxyParamCaption}\item[{}]{opt,  }\item[{}]{fnames,  }\item[{}]{model\+\_\+folder,  }\item[{}]{version = {\ttfamily \textquotesingle{}v1.0\textquotesingle{}},  }\item[{}]{path = {\ttfamily \textquotesingle{}aws\textquotesingle{}},  }\item[{}]{use\+\_\+model\+\_\+type = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Download models into the ParlAI model zoo from a url.

:param fnames: list of filenames to download
:param model_folder: models will be downloaded into models/model_folder/model_type
:param path: url for downloading models; defaults to downloading from AWS
:param use_model_type: whether models are categorized by type in AWS
\end{DoxyVerb}
 

Definition at line 353 of file build\+\_\+data.\+py.


\begin{DoxyCode}
353 ):
354     \textcolor{stringliteral}{"""}
355 \textcolor{stringliteral}{    Download models into the ParlAI model zoo from a url.}
356 \textcolor{stringliteral}{}
357 \textcolor{stringliteral}{    :param fnames: list of filenames to download}
358 \textcolor{stringliteral}{    :param model\_folder: models will be downloaded into models/model\_folder/model\_type}
359 \textcolor{stringliteral}{    :param path: url for downloading models; defaults to downloading from AWS}
360 \textcolor{stringliteral}{    :param use\_model\_type: whether models are categorized by type in AWS}
361 \textcolor{stringliteral}{    """}
362     model\_type = opt.get(\textcolor{stringliteral}{'model\_type'}, \textcolor{keywordtype}{None})
363     \textcolor{keywordflow}{if} model\_type \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
364         dpath = os.path.join(opt[\textcolor{stringliteral}{'datapath'}], \textcolor{stringliteral}{'models'}, model\_folder, model\_type)
365     \textcolor{keywordflow}{else}:
366         dpath = os.path.join(opt[\textcolor{stringliteral}{'datapath'}], \textcolor{stringliteral}{'models'}, model\_folder)
367 
368     \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} \hyperlink{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}{built}(dpath, version):
369         \textcolor{keywordflow}{for} fname \textcolor{keywordflow}{in} fnames:
370             print(\textcolor{stringliteral}{'[building data: '} + dpath + \textcolor{stringliteral}{'/'} + fname + \textcolor{stringliteral}{']'})
371         \textcolor{keywordflow}{if} \hyperlink{namespaceparlai_1_1core_1_1build__data_ad834e1a9be02e18a6c2de2b03b9a8f10}{built}(dpath):
372             \textcolor{comment}{# An older version exists, so remove these outdated files.}
373             \hyperlink{namespaceparlai_1_1core_1_1build__data_a24ab3b7e68e41adf774df058d330ff33}{remove\_dir}(dpath)
374         \hyperlink{namespaceparlai_1_1core_1_1build__data_a6ce042fedd4194bd016845bbe7a8facf}{make\_dir}(dpath)
375 
376         \textcolor{comment}{# Download the data.}
377         \textcolor{keywordflow}{for} fname \textcolor{keywordflow}{in} fnames:
378             \textcolor{keywordflow}{if} path == \textcolor{stringliteral}{'aws'}:
379                 url = \textcolor{stringliteral}{'http://parl.ai/downloads/\_models/'}
380                 url += model\_folder + \textcolor{stringliteral}{'/'}
381                 \textcolor{keywordflow}{if} use\_model\_type:
382                     url += model\_type + \textcolor{stringliteral}{'/'}
383                 url += fname
384             \textcolor{keywordflow}{else}:
385                 url = path + \textcolor{stringliteral}{'/'} + fname
386             \hyperlink{namespaceparlai_1_1core_1_1build__data_ab74f0e428f05e5d91fa93c8afb367622}{download}(url, dpath, fname)
387             \textcolor{keywordflow}{if} \textcolor{stringliteral}{'.tgz'} \textcolor{keywordflow}{in} fname \textcolor{keywordflow}{or} \textcolor{stringliteral}{'.gz'} \textcolor{keywordflow}{in} fname \textcolor{keywordflow}{or} \textcolor{stringliteral}{'.zip'} \textcolor{keywordflow}{in} fname:
388                 \hyperlink{namespaceparlai_1_1core_1_1build__data_a4d33f97932682a8513904022d852f3cf}{untar}(dpath, fname)
389         \textcolor{comment}{# Mark the data as built.}
390         \hyperlink{namespaceparlai_1_1core_1_1build__data_a2527e6d29b0ccb7b841182890ac36a59}{mark\_done}(dpath, version)
391 
392 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ae259aeb321a77560fbcd23028178c897}\label{namespaceparlai_1_1core_1_1build__data_ae259aeb321a77560fbcd23028178c897}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!download\+\_\+multiprocess@{download\+\_\+multiprocess}}
\index{download\+\_\+multiprocess@{download\+\_\+multiprocess}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{download\+\_\+multiprocess()}{download\_multiprocess()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+download\+\_\+multiprocess (\begin{DoxyParamCaption}\item[{}]{urls,  }\item[{}]{path,  }\item[{}]{num\+\_\+processes = {\ttfamily 32},  }\item[{}]{chunk\+\_\+size = {\ttfamily 100},  }\item[{}]{dest\+\_\+filenames = {\ttfamily None},  }\item[{}]{error\+\_\+path = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Download items in parallel (e.g. for an image + dialogue task).

WARNING: may have issues with OS X.

:param urls:
    Array of urls to download
:param path:
    directory to save items in
:param num_processes:
    number of processes to use
:param chunk_size:
    chunk size to use
:param dest_filenames:
    optional array of same length as url with filenames.  Images will be
    saved as path + dest_filename
:param error_path:
    where to save error logs
:return:
    array of tuples of (destination filename, http status code, error
    message if any). Note that upon failure, file may not actually be
    created.
\end{DoxyVerb}
 

Definition at line 445 of file build\+\_\+data.\+py.


\begin{DoxyCode}
445 ):
446     \textcolor{stringliteral}{"""}
447 \textcolor{stringliteral}{    Download items in parallel (e.g. for an image + dialogue task).}
448 \textcolor{stringliteral}{}
449 \textcolor{stringliteral}{    WARNING: may have issues with OS X.}
450 \textcolor{stringliteral}{}
451 \textcolor{stringliteral}{    :param urls:}
452 \textcolor{stringliteral}{        Array of urls to download}
453 \textcolor{stringliteral}{    :param path:}
454 \textcolor{stringliteral}{        directory to save items in}
455 \textcolor{stringliteral}{    :param num\_processes:}
456 \textcolor{stringliteral}{        number of processes to use}
457 \textcolor{stringliteral}{    :param chunk\_size:}
458 \textcolor{stringliteral}{        chunk size to use}
459 \textcolor{stringliteral}{    :param dest\_filenames:}
460 \textcolor{stringliteral}{        optional array of same length as url with filenames.  Images will be}
461 \textcolor{stringliteral}{        saved as path + dest\_filename}
462 \textcolor{stringliteral}{    :param error\_path:}
463 \textcolor{stringliteral}{        where to save error logs}
464 \textcolor{stringliteral}{    :return:}
465 \textcolor{stringliteral}{        array of tuples of (destination filename, http status code, error}
466 \textcolor{stringliteral}{        message if any). Note that upon failure, file may not actually be}
467 \textcolor{stringliteral}{        created.}
468 \textcolor{stringliteral}{    """}
469 
470     pbar = tqdm.tqdm(total=len(urls), position=0)
471 
472     \textcolor{comment}{# Resume TODO: isfile() may take too long ?? Should I try in a .tmp file}
473     \textcolor{keywordflow}{if} dest\_filenames:
474         \textcolor{keywordflow}{if} len(dest\_filenames) != len(urls):
475             \textcolor{keywordflow}{raise} Exception(
476                 \textcolor{stringliteral}{'If specified, destination filenames must equal url array in length.'}
477             )
478     \textcolor{keywordflow}{else}:
479 
480         \textcolor{keyword}{def }\_naming\_fn(url, url\_metadata=None):
481             \textcolor{keywordflow}{return} hashlib.md5(url.encode(\textcolor{stringliteral}{'utf-8'})).hexdigest()
482 
483         dest\_filenames = [\_naming\_fn(url) \textcolor{keywordflow}{for} url \textcolor{keywordflow}{in} urls]
484 
485     items = zip(urls, dest\_filenames)
486     remaining\_items = [
487         it \textcolor{keywordflow}{for} it \textcolor{keywordflow}{in} items \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} os.path.isfile(os.path.join(path, it[1]))
488     ]
489     print(
490         f\textcolor{stringliteral}{'Of \{len(urls)\} items, \{len(urls) - len(remaining\_items)\} already existed; only going to download
       \{len(remaining\_items)\} items.'}
491     )
492     pbar.update(len(urls) - len(remaining\_items))
493 
494     pool\_chunks = (
495         (remaining\_items[i : i + chunk\_size], path, \_download\_multiprocess\_single)
496         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(0, len(remaining\_items), chunk\_size)
497     )
498     remaining\_chunks\_count = math.ceil(\hyperlink{namespaceprojects_1_1controllable__dialogue_1_1make__control__dataset_aa2b7207688c641dbc094ab44eca27113}{float}(len(remaining\_items) / chunk\_size))
499     print(
500         f\textcolor{stringliteral}{'Going to download \{remaining\_chunks\_count\} chunks with \{chunk\_size\} images per chunk using
       \{num\_processes\} processes.'}
501     )
502 
503     pbar.desc = \textcolor{stringliteral}{'Downloading'}
504     all\_results = []
505     collected\_errors = []
506 
507     with Pool(num\_processes) \textcolor{keyword}{as} pool:
508         \textcolor{keywordflow}{for} idx, chunk\_result \textcolor{keywordflow}{in} enumerate(
509             pool.imap\_unordered(\_download\_multiprocess\_map\_chunk, pool\_chunks, 2)
510         ):
511             all\_results.extend(chunk\_result)
512             \textcolor{keywordflow}{for} dest\_file, http\_status\_code, error\_msg \textcolor{keywordflow}{in} chunk\_result:
513                 \textcolor{keywordflow}{if} http\_status\_code != 200:
514                     \textcolor{comment}{# msg field available as third item in the tuple}
515                     \textcolor{comment}{# not using b/c error log file would blow up}
516                     collected\_errors.append(
517                         \{
518                             \textcolor{stringliteral}{'dest\_file'}: dest\_file,
519                             \textcolor{stringliteral}{'status\_code'}: http\_status\_code,
520                             \textcolor{stringliteral}{'error'}: error\_msg,
521                         \}
522                     )
523                     print(
524                         f\textcolor{stringliteral}{'Bad download - chunk: \{idx\}, dest\_file: \{dest\_file\}, http status code:
       \{http\_status\_code\}, error\_msg: \{error\_msg\}'}
525                     )
526             pbar.update(len(chunk\_result))
527     pbar.close()
528 
529     \textcolor{keywordflow}{if} error\_path:
530         now = time.strftime(\textcolor{stringliteral}{"%Y%m%d-%H%M%S"})
531         error\_filename = os.path.join(
532             error\_path, \textcolor{stringliteral}{'parlai\_download\_multiprocess\_errors\_%s.log'} % now
533         )
534 
535         with open(os.path.join(error\_filename), \textcolor{stringliteral}{'w+'}) \textcolor{keyword}{as} error\_file:
536             error\_file.write(json.dumps(collected\_errors))
537             print(\textcolor{stringliteral}{'Summary of errors written to %s'} % error\_filename)
538 
539     print(
540         \textcolor{stringliteral}{'Of %s items attempted downloading, %s had errors.'}
541         % (len(remaining\_items), len(collected\_errors))
542     )
543 
544     print(\textcolor{stringliteral}{'Finished downloading chunks.'})
545     \textcolor{keywordflow}{return} all\_results
546 
547 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ad2fe6222094caae59f304931aee0952a}\label{namespaceparlai_1_1core_1_1build__data_ad2fe6222094caae59f304931aee0952a}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!get\+\_\+model\+\_\+dir@{get\+\_\+model\+\_\+dir}}
\index{get\+\_\+model\+\_\+dir@{get\+\_\+model\+\_\+dir}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{get\+\_\+model\+\_\+dir()}{get\_model\_dir()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+get\+\_\+model\+\_\+dir (\begin{DoxyParamCaption}\item[{}]{datapath }\end{DoxyParamCaption})}



Definition at line 347 of file build\+\_\+data.\+py.


\begin{DoxyCode}
347 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_ad2fe6222094caae59f304931aee0952a}{get\_model\_dir}(datapath):
348     \textcolor{keywordflow}{return} os.path.join(datapath, \textcolor{stringliteral}{'models'})
349 
350 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a6ce042fedd4194bd016845bbe7a8facf}\label{namespaceparlai_1_1core_1_1build__data_a6ce042fedd4194bd016845bbe7a8facf}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!make\+\_\+dir@{make\+\_\+dir}}
\index{make\+\_\+dir@{make\+\_\+dir}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{make\+\_\+dir()}{make\_dir()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+make\+\_\+dir (\begin{DoxyParamCaption}\item[{}]{path }\end{DoxyParamCaption})}

\begin{DoxyVerb}Make the directory and any nonexistent parent directories (`mkdir -p`).
\end{DoxyVerb}
 

Definition at line 239 of file build\+\_\+data.\+py.


\begin{DoxyCode}
239 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a6ce042fedd4194bd016845bbe7a8facf}{make\_dir}(path):
240     \textcolor{stringliteral}{"""}
241 \textcolor{stringliteral}{    Make the directory and any nonexistent parent directories (`mkdir -p`).}
242 \textcolor{stringliteral}{    """}
243     \textcolor{comment}{# the current working directory is a fine path}
244     \textcolor{keywordflow}{if} path != \textcolor{stringliteral}{''}:
245         os.makedirs(path, exist\_ok=\textcolor{keyword}{True})
246 
247 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a2527e6d29b0ccb7b841182890ac36a59}\label{namespaceparlai_1_1core_1_1build__data_a2527e6d29b0ccb7b841182890ac36a59}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!mark\+\_\+done@{mark\+\_\+done}}
\index{mark\+\_\+done@{mark\+\_\+done}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{mark\+\_\+done()}{mark\_done()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+mark\+\_\+done (\begin{DoxyParamCaption}\item[{}]{path,  }\item[{}]{version\+\_\+string = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mark this path as prebuilt.

Marks the path as done by adding a '.built' file with the current timestamp
plus a version description string if specified.

:param str path:
    The file path to mark as built.

:param str version_string:
    The version of this dataset.
\end{DoxyVerb}
 

Definition at line 132 of file build\+\_\+data.\+py.


\begin{DoxyCode}
132 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a2527e6d29b0ccb7b841182890ac36a59}{mark\_done}(path, version\_string=None):
133     \textcolor{stringliteral}{"""}
134 \textcolor{stringliteral}{    Mark this path as prebuilt.}
135 \textcolor{stringliteral}{}
136 \textcolor{stringliteral}{    Marks the path as done by adding a '.built' file with the current timestamp}
137 \textcolor{stringliteral}{    plus a version description string if specified.}
138 \textcolor{stringliteral}{}
139 \textcolor{stringliteral}{    :param str path:}
140 \textcolor{stringliteral}{        The file path to mark as built.}
141 \textcolor{stringliteral}{}
142 \textcolor{stringliteral}{    :param str version\_string:}
143 \textcolor{stringliteral}{        The version of this dataset.}
144 \textcolor{stringliteral}{    """}
145     with open(os.path.join(path, \textcolor{stringliteral}{'.built'}), \textcolor{stringliteral}{'w'}) \textcolor{keyword}{as} write:
146         write.write(\hyperlink{namespacegenerate__task__READMEs_a5b88452ffb87b78c8c85ececebafc09f}{str}(datetime.datetime.today()))
147         \textcolor{keywordflow}{if} version\_string:
148             write.write(\textcolor{stringliteral}{'\(\backslash\)n'} + version\_string)
149 
150 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_ad06e9e38ca85db9c4a676ccd9ae41649}\label{namespaceparlai_1_1core_1_1build__data_ad06e9e38ca85db9c4a676ccd9ae41649}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!modelzoo\+\_\+path@{modelzoo\+\_\+path}}
\index{modelzoo\+\_\+path@{modelzoo\+\_\+path}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{modelzoo\+\_\+path()}{modelzoo\_path()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+modelzoo\+\_\+path (\begin{DoxyParamCaption}\item[{}]{datapath,  }\item[{}]{path }\end{DoxyParamCaption})}

\begin{DoxyVerb}Map pretrain models filenames to their path on disk.

If path starts with 'models:', then we remap it to the model zoo path within the
data directory (default is ParlAI/data/models). We download models from the model
zoo if they are not here yet.
\end{DoxyVerb}
 

Definition at line 393 of file build\+\_\+data.\+py.


\begin{DoxyCode}
393 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_ad06e9e38ca85db9c4a676ccd9ae41649}{modelzoo\_path}(datapath, path):
394     \textcolor{stringliteral}{"""}
395 \textcolor{stringliteral}{    Map pretrain models filenames to their path on disk.}
396 \textcolor{stringliteral}{}
397 \textcolor{stringliteral}{    If path starts with 'models:', then we remap it to the model zoo path within the}
398 \textcolor{stringliteral}{    data directory (default is ParlAI/data/models). We download models from the model}
399 \textcolor{stringliteral}{    zoo if they are not here yet.}
400 \textcolor{stringliteral}{    """}
401     \textcolor{keywordflow}{if} path \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
402         \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}
403     \textcolor{keywordflow}{if} (
404         \textcolor{keywordflow}{not} path.startswith(\textcolor{stringliteral}{'models:'})
405         \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} path.startswith(\textcolor{stringliteral}{'zoo:'})
406         \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} path.startswith(\textcolor{stringliteral}{'izoo:'})
407     ):
408         \textcolor{keywordflow}{return} path
409     \textcolor{keywordflow}{elif} path.startswith(\textcolor{stringliteral}{'models:'}) \textcolor{keywordflow}{or} path.startswith(\textcolor{stringliteral}{'zoo:'}):
410         zoo = path.split(\textcolor{stringliteral}{':'})[0]
411         zoo\_len = len(zoo) + 1
412         model\_path = path[zoo\_len:]
413         \textcolor{comment}{# Check if we need to download the model}
414         animal = path[zoo\_len : path.rfind(\textcolor{stringliteral}{'/'})].replace(\textcolor{stringliteral}{'/'}, \textcolor{stringliteral}{'.'})
415         \textcolor{keywordflow}{if} \textcolor{stringliteral}{'.'} \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} animal:
416             animal += \textcolor{stringliteral}{'.build'}
417         module\_name = \textcolor{stringliteral}{'parlai.zoo.\{\}'}.\hyperlink{namespaceparlai_1_1chat__service_1_1services_1_1messenger_1_1shared__utils_a32e2e2022b824fbaf80c747160b52a76}{format}(animal)
418         \textcolor{keywordflow}{try}:
419             my\_module = importlib.import\_module(module\_name)
420             my\_module.download(datapath)
421         \textcolor{keywordflow}{except} (ImportError, AttributeError):
422             \textcolor{keywordflow}{pass}
423 
424         \textcolor{keywordflow}{return} os.path.join(datapath, \textcolor{stringliteral}{'models'}, model\_path)
425     \textcolor{keywordflow}{else}:
426         \textcolor{comment}{# Internal path (starts with "izoo:") -- useful for non-public}
427         \textcolor{comment}{# projects.  Save the path to your internal model zoo in}
428         \textcolor{comment}{# parlai\_internal/.internal\_zoo\_path}
429         \textcolor{comment}{# TODO: test the internal zoo.}
430         zoo\_path = \textcolor{stringliteral}{'parlai\_internal/zoo/.internal\_zoo\_path'}
431         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} os.path.isfile(\textcolor{stringliteral}{'parlai\_internal/zoo/.internal\_zoo\_path'}):
432             \textcolor{keywordflow}{raise} RuntimeError(
433                 \textcolor{stringliteral}{'Please specify the path to your internal zoo in the '}
434                 \textcolor{stringliteral}{'file parlai\_internal/zoo/.internal\_zoo\_path in your '}
435                 \textcolor{stringliteral}{'internal repository.'}
436             )
437         \textcolor{keywordflow}{else}:
438             with open(zoo\_path, \textcolor{stringliteral}{'r') as f:}
439 \textcolor{stringliteral}{                zoo = f.read().split('\(\backslash\)n'})[0]
440             \textcolor{keywordflow}{return} os.path.join(zoo, path[5:])
441 
442 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a1678b8a042eeb9d9c8e9de08f52e496b}\label{namespaceparlai_1_1core_1_1build__data_a1678b8a042eeb9d9c8e9de08f52e496b}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!move@{move}}
\index{move@{move}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{move()}{move()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+move (\begin{DoxyParamCaption}\item[{}]{path1,  }\item[{}]{path2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Rename the given file.
\end{DoxyVerb}
 

Definition at line 248 of file build\+\_\+data.\+py.


\begin{DoxyCode}
248 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a1678b8a042eeb9d9c8e9de08f52e496b}{move}(path1, path2):
249     \textcolor{stringliteral}{"""}
250 \textcolor{stringliteral}{    Rename the given file.}
251 \textcolor{stringliteral}{    """}
252     shutil.move(path1, path2)
253 
254 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a24ab3b7e68e41adf774df058d330ff33}\label{namespaceparlai_1_1core_1_1build__data_a24ab3b7e68e41adf774df058d330ff33}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!remove\+\_\+dir@{remove\+\_\+dir}}
\index{remove\+\_\+dir@{remove\+\_\+dir}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{remove\+\_\+dir()}{remove\_dir()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+remove\+\_\+dir (\begin{DoxyParamCaption}\item[{}]{path }\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove the given directory, if it exists.
\end{DoxyVerb}
 

Definition at line 255 of file build\+\_\+data.\+py.


\begin{DoxyCode}
255 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a24ab3b7e68e41adf774df058d330ff33}{remove\_dir}(path):
256     \textcolor{stringliteral}{"""}
257 \textcolor{stringliteral}{    Remove the given directory, if it exists.}
258 \textcolor{stringliteral}{    """}
259     shutil.rmtree(path, ignore\_errors=\textcolor{keyword}{True})
260 
261 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a4d33f97932682a8513904022d852f3cf}\label{namespaceparlai_1_1core_1_1build__data_a4d33f97932682a8513904022d852f3cf}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!untar@{untar}}
\index{untar@{untar}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{untar()}{untar()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+untar (\begin{DoxyParamCaption}\item[{}]{path,  }\item[{}]{fname,  }\item[{}]{delete\+Tar = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unpack the given archive file to the same directory.

:param str path:
    The folder containing the archive. Will contain the contents.

:param str fname:
    The filename of the archive file.

:param bool deleteTar:
    If true, the archive will be deleted after extraction.
\end{DoxyVerb}
 

Definition at line 262 of file build\+\_\+data.\+py.


\begin{DoxyCode}
262 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a4d33f97932682a8513904022d852f3cf}{untar}(path, fname, deleteTar=True):
263     \textcolor{stringliteral}{"""}
264 \textcolor{stringliteral}{    Unpack the given archive file to the same directory.}
265 \textcolor{stringliteral}{}
266 \textcolor{stringliteral}{    :param str path:}
267 \textcolor{stringliteral}{        The folder containing the archive. Will contain the contents.}
268 \textcolor{stringliteral}{}
269 \textcolor{stringliteral}{    :param str fname:}
270 \textcolor{stringliteral}{        The filename of the archive file.}
271 \textcolor{stringliteral}{}
272 \textcolor{stringliteral}{    :param bool deleteTar:}
273 \textcolor{stringliteral}{        If true, the archive will be deleted after extraction.}
274 \textcolor{stringliteral}{    """}
275     print(\textcolor{stringliteral}{'unpacking '} + fname)
276     fullpath = os.path.join(path, fname)
277     shutil.unpack\_archive(fullpath, path)
278     \textcolor{keywordflow}{if} deleteTar:
279         os.remove(fullpath)
280 
281 
\end{DoxyCode}
\mbox{\Hypertarget{namespaceparlai_1_1core_1_1build__data_a7cbfdf246ca40dc3ed9f8613deb14a00}\label{namespaceparlai_1_1core_1_1build__data_a7cbfdf246ca40dc3ed9f8613deb14a00}} 
\index{parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}!unzip@{unzip}}
\index{unzip@{unzip}!parlai\+::core\+::build\+\_\+data@{parlai\+::core\+::build\+\_\+data}}
\subsubsection{\texorpdfstring{unzip()}{unzip()}}
{\footnotesize\ttfamily def parlai.\+core.\+build\+\_\+data.\+unzip (\begin{DoxyParamCaption}\item[{}]{path,  }\item[{}]{fname,  }\item[{}]{delete\+Zip = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unzip the given archive file to the same directory.

:param str path:
    The folder containing the archive. Will contain the contents.

:param str fname:
    The filename of the archive file.

:param bool deleteZip:
    If true, the archive will be deleted after extraction.
\end{DoxyVerb}
 

Definition at line 282 of file build\+\_\+data.\+py.


\begin{DoxyCode}
282 \textcolor{keyword}{def }\hyperlink{namespaceparlai_1_1core_1_1build__data_a7cbfdf246ca40dc3ed9f8613deb14a00}{unzip}(path, fname, deleteZip=True):
283     \textcolor{stringliteral}{"""}
284 \textcolor{stringliteral}{    Unzip the given archive file to the same directory.}
285 \textcolor{stringliteral}{}
286 \textcolor{stringliteral}{    :param str path:}
287 \textcolor{stringliteral}{        The folder containing the archive. Will contain the contents.}
288 \textcolor{stringliteral}{}
289 \textcolor{stringliteral}{    :param str fname:}
290 \textcolor{stringliteral}{        The filename of the archive file.}
291 \textcolor{stringliteral}{}
292 \textcolor{stringliteral}{    :param bool deleteZip:}
293 \textcolor{stringliteral}{        If true, the archive will be deleted after extraction.}
294 \textcolor{stringliteral}{    """}
295     print(\textcolor{stringliteral}{'unzipping '} + fname)
296     fullpath = os.path.join(path, fname)
297     with zipfile.ZipFile(fullpath, \textcolor{stringliteral}{"r") as zip\_ref:}
298 \textcolor{stringliteral}{        zip\_ref.extractall(path)}
299 \textcolor{stringliteral}{    }\textcolor{keywordflow}{if} deleteZip:
300         os.remove(fullpath)
301 
302 
\end{DoxyCode}
