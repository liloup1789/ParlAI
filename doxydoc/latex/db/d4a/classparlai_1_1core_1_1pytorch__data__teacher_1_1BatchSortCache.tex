\hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache}{}\section{parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache Class Reference}
\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache}\index{parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache@{parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache}}


Inheritance diagram for parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=233pt]{d0/d81/classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=233pt]{de/d99/classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a272dbfe6529aa39066b4ad8504f40f5d}{create} (cls)
\item 
def \hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a115f5df4f4fafa087f592e9a0ab48d9c}{destroy} (cls)
\item 
def \hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ae97120b4fec464f79c7d0d9cd54c101d}{batch\+\_\+cache} (cls, function)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a68076c873c29c3752c391937c2fe6adc}{length\+\_\+to\+\_\+eps}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a85c90f8ae87edc9a122c8cdea6854857}{ep\+\_\+indices}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a892022928bc71b59225d16eefbbfdf60}{batches}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a50725d8fc600b792cd856d1ff4bdaca3}{load\+\_\+complete}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a535808bc8ccedb06dd0a09d9306ed84c}{batches\+\_\+lock}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a3b85c080ff697ef4454ca452837b5107}{cache\+\_\+lock}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a668f1a87f3c5c4776bf06c884ef344d5}{fill\+\_\+cache\+\_\+lock}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_aee6ea11fd9febb0d4178127cffd63561}{add\+\_\+to\+\_\+cache\+\_\+cv}
\item 
\hyperlink{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ad35a73a670bf0aab8f9b9bf7caffe207}{cache\+\_\+filled\+\_\+cv}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Object that encapsulates the functionality of the batch sort cache.

Maps episode length to dictionary with following keys:

- ``current_idx``: which episode in the list are we at (if simply indexing
  into list)
- ``ep_list``: list of episodes of the length of the key
- ``bucket_complete``: if there are no more episodes left to consider in the
  bucket
\end{DoxyVerb}
 

Definition at line 44 of file pytorch\+\_\+data\+\_\+teacher.\+py.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ae97120b4fec464f79c7d0d9cd54c101d}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ae97120b4fec464f79c7d0d9cd54c101d}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!batch\+\_\+cache@{batch\+\_\+cache}}
\index{batch\+\_\+cache@{batch\+\_\+cache}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{batch\+\_\+cache()}{batch\_cache()}}
{\footnotesize\ttfamily def parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+batch\+\_\+cache (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{function }\end{DoxyParamCaption})}

\begin{DoxyVerb}Create the cache of batches.
\end{DoxyVerb}
 

Definition at line 99 of file pytorch\+\_\+data\+\_\+teacher.\+py.


\begin{DoxyCode}
99     \textcolor{keyword}{def }batch\_cache(cls, function):
100         \textcolor{stringliteral}{"""}
101 \textcolor{stringliteral}{        Create the cache of batches.}
102 \textcolor{stringliteral}{        """}
103         max\_cache\_size = 10000  \textcolor{comment}{# Max unseen eps}
104         min\_cache\_size = 1000  \textcolor{comment}{# Min unseen eps}
105 
106         \textcolor{keyword}{def }get\_cache\_size():
107             \textcolor{stringliteral}{"""}
108 \textcolor{stringliteral}{            Return number of available episodes.}
109 \textcolor{stringliteral}{            """}
110             \textcolor{keywordflow}{return} sum(
111                 len(v[\textcolor{stringliteral}{'ep\_list'}]) - v[\textcolor{stringliteral}{'current\_idx'}]
112                 \textcolor{keywordflow}{for} k, v \textcolor{keywordflow}{in} cls.length\_to\_eps.items()
113             )
114 
115         \textcolor{keyword}{def }get\_available\_buckets(bsz):
116             \textcolor{stringliteral}{"""}
117 \textcolor{stringliteral}{            Return buckets where there are enough episodes for a batch.}
118 \textcolor{stringliteral}{            """}
119             \textcolor{keywordflow}{if} cls.load\_complete.value:
120                 \textcolor{keywordflow}{return} \{
121                     k: v
122                     \textcolor{keywordflow}{for} k, v \textcolor{keywordflow}{in} cls.length\_to\_eps.items()
123                     \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} v[\textcolor{stringliteral}{'bucket\_complete'}]
124                     \textcolor{keywordflow}{or} len(v[\textcolor{stringliteral}{'ep\_list'}]) - v[\textcolor{stringliteral}{'current\_idx'}] > 0
125                 \}
126             \textcolor{keywordflow}{else}:
127                 \textcolor{keywordflow}{return} \{
128                     k: v
129                     \textcolor{keywordflow}{for} k, v \textcolor{keywordflow}{in} cls.length\_to\_eps.items()
130                     \textcolor{keywordflow}{if} len(v[\textcolor{stringliteral}{'ep\_list'}]) - v[\textcolor{stringliteral}{'current\_idx'}] >= bsz
131                 \}
132 
133         \textcolor{keyword}{def }reset():
134             \textcolor{stringliteral}{"""}
135 \textcolor{stringliteral}{            Reset the indices into the buckets.}
136 \textcolor{stringliteral}{            """}
137             with cls.cache\_lock:
138                 \textcolor{keywordflow}{for} idx \textcolor{keywordflow}{in} cls.length\_to\_eps:
139                     cls.length\_to\_eps[idx][\textcolor{stringliteral}{'current\_idx'}] = 0
140                     cls.length\_to\_eps[idx][\textcolor{stringliteral}{'bucket\_complete'}] = \textcolor{keyword}{False}
141 
142         \textcolor{keyword}{def }consolidate(caller):
143             \textcolor{stringliteral}{"""}
144 \textcolor{stringliteral}{            Consolidate remaining episodes into batches.}
145 \textcolor{stringliteral}{            """}
146             cls.load\_complete.value = \textcolor{keyword}{True}
147             bsz = caller.bsz
148             batch = []
149             sorted\_lengths = sorted(cls.length\_to\_eps.keys())
150             with cls.cache\_lock:
151                 \textcolor{keywordflow}{if} caller.batch\_cache\_type == \textcolor{stringliteral}{'index'}:
152                     \textcolor{keywordflow}{for} length \textcolor{keywordflow}{in} sorted\_lengths:
153                         current\_idx = cls.length\_to\_eps[length][\textcolor{stringliteral}{'current\_idx'}]
154                         ep\_list = cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}]
155                         unseen\_eps = ep\_list[current\_idx:]
156                         cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}] = ep\_list[:current\_idx]
157                         batch = unseen\_eps + batch
158                         \textcolor{keywordflow}{while} len(batch) >= bsz:
159                             cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}] += batch[:bsz]
160                             batch = batch[bsz:]
161                     \textcolor{keywordflow}{if} len(batch) > 0:
162                         cls.length\_to\_eps[-1] = \{
163                             \textcolor{stringliteral}{'current\_idx'}: 0,
164                             \textcolor{stringliteral}{'ep\_list'}: batch,
165                             \textcolor{stringliteral}{'bucket\_complete'}: \textcolor{keyword}{False},
166                         \}
167                 \textcolor{keywordflow}{elif} caller.batch\_cache\_type == \textcolor{stringliteral}{'pop'}:
168                     \textcolor{keywordflow}{for} length \textcolor{keywordflow}{in} sorted\_lengths:
169                         batch += cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}]
170                     with cls.batches\_lock:
171                         \textcolor{keywordflow}{while} len(batch) >= bsz:
172                             cls.batches.append(batch[:bsz])
173                             batch = batch[bsz:]
174                     \textcolor{keywordflow}{if} len(batch) > 0:
175                         with cls.batches\_lock:
176                             cls.batches.append(batch)
177 
178         \textcolor{keyword}{def }\hyperlink{namespaceprojects_1_1controllable__dialogue_1_1controllable__seq2seq_1_1controls_a0db4b9d9584cef90aa2515a75e741774}{flatten}(l):
179             \textcolor{stringliteral}{"""}
180 \textcolor{stringliteral}{            Flatten a list.}
181 \textcolor{stringliteral}{            """}
182             \textcolor{keywordflow}{return} [item \textcolor{keywordflow}{for} sublist \textcolor{keywordflow}{in} l \textcolor{keywordflow}{for} item \textcolor{keywordflow}{in} sublist]
183 
184         \textcolor{keyword}{def }put\_in\_cache(ep\_idx, episode, caller):
185             \textcolor{stringliteral}{"""}
186 \textcolor{stringliteral}{            Put episode `ep\_idx` into cache.}
187 \textcolor{stringliteral}{            """}
188             length = \hyperlink{namespaceparlai_1_1core_1_1pytorch__data__teacher_afbd22acd239efcdb6afb94db83ee3493}{ep\_length}(episode[caller.batch\_sort\_field])
189             lengths = [length] + \hyperlink{namespaceprojects_1_1controllable__dialogue_1_1controllable__seq2seq_1_1controls_a0db4b9d9584cef90aa2515a75e741774}{flatten}(
190                 [
191                     [length + i, length + (i * -1)]
192                     \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(1, caller.batch\_length\_range)
193                 ]
194             )
195             lengths = [max(i, 1) \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} lengths]
196             in\_cache = ep\_idx \textcolor{keywordflow}{in} cls.ep\_indices
197             \textcolor{comment}{# first check if episode can go in existing bucket}
198             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} in\_cache:
199                 \textcolor{keywordflow}{for} l \textcolor{keywordflow}{in} lengths:
200                     \textcolor{keywordflow}{if} l \textcolor{keywordflow}{in} cls.length\_to\_eps:
201                         with cls.cache\_lock:
202                             cls.length\_to\_eps[l][\textcolor{stringliteral}{'ep\_list'}] += [(ep\_idx, episode)]
203                             cls.ep\_indices.add(ep\_idx)
204                         in\_cache = \textcolor{keyword}{True}
205                         \textcolor{keywordflow}{break}
206             \textcolor{comment}{# otherwise, make a new bucket}
207             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} in\_cache:
208                 with cls.cache\_lock:
209                     cls.length\_to\_eps[length] = \{
210                         \textcolor{stringliteral}{'current\_idx'}: 0,
211                         \textcolor{stringliteral}{'ep\_list'}: [(ep\_idx, episode)],
212                         \textcolor{stringliteral}{'bucket\_complete'}: \textcolor{keyword}{False},
213                     \}
214                     cls.ep\_indices.add(ep\_idx)
215             \textcolor{keywordflow}{if} ep\_idx == caller.dataset.num\_episodes() - 1:
216                 consolidate(caller)
217                 with cls.add\_to\_cache\_cv:
218                     cls.cache\_filled\_cv.notify\_all()
219 
220         @wraps(function)
221         \textcolor{keyword}{def }wrapper(*args):
222             \textcolor{stringliteral}{"""}
223 \textcolor{stringliteral}{            Wrap a function.}
224 \textcolor{stringliteral}{            """}
225             \textcolor{comment}{# TODO: refactor}
226             caller = args[0]
227             batch\_sort = caller.batch\_sort
228             batch\_cache\_type = caller.batch\_cache\_type
229             bsz = caller.bsz
230             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} batch\_sort \textcolor{keywordflow}{or} \textcolor{keywordflow}{not} caller.datatype.startswith(\textcolor{stringliteral}{'train'}):
231                 \textcolor{keywordflow}{return} function(*args)
232             \textcolor{comment}{# If Loader, put episodes in cache}
233             \textcolor{keywordflow}{if} isinstance(caller, LoaderProcess):
234                 with cls.add\_to\_cache\_cv:
235                     \textcolor{keywordflow}{while} (
236                         get\_cache\_size() >= max\_cache\_size
237                         \textcolor{keywordflow}{and} len(get\_available\_buckets(bsz)) > 0
238                     ):
239                         cls.cache\_filled\_cv.notify\_all()
240                         cls.add\_to\_cache\_cv.\hyperlink{namespaceparlai_1_1mturk_1_1scripts_1_1auto__complete__hit_a41016a44ce805b615732efe5c479551c}{wait}()
241                 idx\_and\_batch = function(*args)
242                 \textcolor{keywordflow}{if} idx\_and\_batch \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
243                     \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}
244                 \textcolor{keywordflow}{for} ep\_index, ep \textcolor{keywordflow}{in} idx\_and\_batch[1]:
245                     put\_in\_cache(ep\_index, ep, caller)
246                 \textcolor{keywordflow}{return} idx\_and\_batch
247             \textcolor{comment}{# If teacher, return batch of episodes}
248             \textcolor{keywordflow}{else}:
249                 teacher = caller
250                 num\_batches = teacher.num\_batches
251                 \textcolor{keywordflow}{while} \textcolor{keyword}{True}:
252                     with cls.cache\_filled\_cv:
253                         \textcolor{keywordflow}{while} \textcolor{keywordflow}{not} cls.load\_complete.value \textcolor{keywordflow}{and} (
254                             get\_cache\_size() <= min\_cache\_size
255                             \textcolor{keywordflow}{or} len(get\_available\_buckets(bsz)) == 0
256                         ):
257                             cls.add\_to\_cache\_cv.notify()
258                             cls.cache\_filled\_cv.\hyperlink{namespaceparlai_1_1mturk_1_1scripts_1_1auto__complete__hit_a41016a44ce805b615732efe5c479551c}{wait}()
259                             available\_buckets = get\_available\_buckets(bsz)
260                     \textcolor{keywordflow}{if} cls.load\_complete.value \textcolor{keywordflow}{and} batch\_cache\_type == \textcolor{stringliteral}{'pop'}:
261                         \textcolor{keywordflow}{return} teacher.batch\_idx + 1, random.choice(cls.batches)
262                     batch = \textcolor{keywordtype}{None}
263                     available\_buckets = get\_available\_buckets(bsz)
264                     \textcolor{keywordflow}{if} len(available\_buckets) != 0:
265                         \textcolor{comment}{# Pick length index at random}
266                         length = random.choice(list(available\_buckets.keys()))
267                         with cls.cache\_lock:
268                             current\_idx = cls.length\_to\_eps[length][\textcolor{stringliteral}{'current\_idx'}]
269                             ep\_list = cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}]
270                             num\_eps = len(ep\_list)
271                             \textcolor{keywordflow}{if} num\_eps - current\_idx >= bsz:
272                                 \textcolor{keywordflow}{if} batch\_cache\_type == \textcolor{stringliteral}{'pop'}:
273                                     batch = ep\_list[:bsz]
274                                     cls.length\_to\_eps[length][\textcolor{stringliteral}{'ep\_list'}] = ep\_list[bsz:]
275                                 \textcolor{keywordflow}{else}:
276                                     batch = ep\_list[current\_idx : current\_idx + bsz]
277                                     cls.length\_to\_eps[length][\textcolor{stringliteral}{'current\_idx'}] = (
278                                         current\_idx + bsz
279                                     )
280                             \textcolor{keywordflow}{elif} cls.load\_complete.value \textcolor{keywordflow}{and} num\_eps > 0:
281                                 \textcolor{keywordflow}{if} batch\_cache\_type == \textcolor{stringliteral}{'pop'}:
282                                     batch = ep\_list
283                                 \textcolor{keywordflow}{elif} num\_eps - current\_idx > 0:
284                                     batch = ep\_list[current\_idx:]
285                                     cls.length\_to\_eps[length][\textcolor{stringliteral}{'current\_idx'}] = (
286                                         num\_eps - 1
287                                     )
288                                 cls.length\_to\_eps[length][\textcolor{stringliteral}{'bucket\_complete'}] = \textcolor{keyword}{True}
289 
290                     \textcolor{keywordflow}{if} batch \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
291                         \textcolor{keywordflow}{if} batch\_cache\_type == \textcolor{stringliteral}{'pop'}:
292                             with cls.batches\_lock:
293                                 cls.batches.append(batch)
294                         \textcolor{keywordflow}{elif} teacher.batch\_idx + 1 >= num\_batches:
295                             reset()
296                         \textcolor{keywordflow}{return} teacher.batch\_idx + 1, batch
297 
298         \textcolor{keywordflow}{return} wrapper
299 
300 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a272dbfe6529aa39066b4ad8504f40f5d}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a272dbfe6529aa39066b4ad8504f40f5d}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!create@{create}}
\index{create@{create}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{create()}{create()}}
{\footnotesize\ttfamily def parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+create (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})}

\begin{DoxyVerb}Singleton factory.
\end{DoxyVerb}
 

Definition at line 58 of file pytorch\+\_\+data\+\_\+teacher.\+py.


\begin{DoxyCode}
58     \textcolor{keyword}{def }create(cls):
59         \textcolor{stringliteral}{"""}
60 \textcolor{stringliteral}{        Singleton factory.}
61 \textcolor{stringliteral}{        """}
62         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} hasattr(cls, \textcolor{stringliteral}{'length\_to\_eps'}):
63             \textcolor{comment}{# Maps episode length to list of episodes}
64             cls.length\_to\_eps = \{\}
65             \textcolor{comment}{# Set of episode indices already in the cache}
66             cls.ep\_indices = set()
67             \textcolor{comment}{# List of batches if popping batches}
68             cls.batches = []
69             \textcolor{comment}{# If all episodes have been loaded into memory}
70             cls.load\_complete = Value(ctypes.c\_bool, \textcolor{keyword}{False})
71             \textcolor{comment}{# Lock to access batches}
72             cls.batches\_lock = Lock()
73             \textcolor{comment}{# Lock to access length\_to\_eps}
74             cls.cache\_lock = Lock()
75             \textcolor{comment}{# Lock for condition variables}
76             cls.fill\_cache\_lock = RLock()
77             \textcolor{comment}{# Condition notifying Loader to add to cache}
78             cls.add\_to\_cache\_cv = Condition(lock=cls.fill\_cache\_lock)
79             \textcolor{comment}{# Condition notifying teacher that cache has episodes}
80             cls.cache\_filled\_cv = Condition(lock=cls.fill\_cache\_lock)
81 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a115f5df4f4fafa087f592e9a0ab48d9c}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a115f5df4f4fafa087f592e9a0ab48d9c}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!destroy@{destroy}}
\index{destroy@{destroy}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{destroy()}{destroy()}}
{\footnotesize\ttfamily def parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+destroy (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})}

\begin{DoxyVerb}Singleton destroyer.
\end{DoxyVerb}
 

Definition at line 83 of file pytorch\+\_\+data\+\_\+teacher.\+py.


\begin{DoxyCode}
83     \textcolor{keyword}{def }destroy(cls):
84         \textcolor{stringliteral}{"""}
85 \textcolor{stringliteral}{        Singleton destroyer.}
86 \textcolor{stringliteral}{        """}
87         \textcolor{keywordflow}{if} hasattr(cls, \textcolor{stringliteral}{'length\_to\_eps'}):
88             del cls.length\_to\_eps
89             del cls.ep\_indices
90             del cls.batches
91             del cls.load\_complete
92             del cls.batches\_lock
93             del cls.cache\_lock
94             del cls.fill\_cache\_lock
95             del cls.add\_to\_cache\_cv
96             del cls.cache\_filled\_cv
97 
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_aee6ea11fd9febb0d4178127cffd63561}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_aee6ea11fd9febb0d4178127cffd63561}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!add\+\_\+to\+\_\+cache\+\_\+cv@{add\+\_\+to\+\_\+cache\+\_\+cv}}
\index{add\+\_\+to\+\_\+cache\+\_\+cv@{add\+\_\+to\+\_\+cache\+\_\+cv}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{add\+\_\+to\+\_\+cache\+\_\+cv}{add\_to\_cache\_cv}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+add\+\_\+to\+\_\+cache\+\_\+cv}



Definition at line 78 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a892022928bc71b59225d16eefbbfdf60}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a892022928bc71b59225d16eefbbfdf60}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!batches@{batches}}
\index{batches@{batches}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{batches}{batches}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+batches}



Definition at line 68 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a535808bc8ccedb06dd0a09d9306ed84c}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a535808bc8ccedb06dd0a09d9306ed84c}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!batches\+\_\+lock@{batches\+\_\+lock}}
\index{batches\+\_\+lock@{batches\+\_\+lock}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{batches\+\_\+lock}{batches\_lock}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+batches\+\_\+lock}



Definition at line 72 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ad35a73a670bf0aab8f9b9bf7caffe207}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_ad35a73a670bf0aab8f9b9bf7caffe207}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!cache\+\_\+filled\+\_\+cv@{cache\+\_\+filled\+\_\+cv}}
\index{cache\+\_\+filled\+\_\+cv@{cache\+\_\+filled\+\_\+cv}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{cache\+\_\+filled\+\_\+cv}{cache\_filled\_cv}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+cache\+\_\+filled\+\_\+cv}



Definition at line 80 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a3b85c080ff697ef4454ca452837b5107}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a3b85c080ff697ef4454ca452837b5107}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!cache\+\_\+lock@{cache\+\_\+lock}}
\index{cache\+\_\+lock@{cache\+\_\+lock}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{cache\+\_\+lock}{cache\_lock}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+cache\+\_\+lock}



Definition at line 74 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a85c90f8ae87edc9a122c8cdea6854857}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a85c90f8ae87edc9a122c8cdea6854857}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!ep\+\_\+indices@{ep\+\_\+indices}}
\index{ep\+\_\+indices@{ep\+\_\+indices}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{ep\+\_\+indices}{ep\_indices}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+ep\+\_\+indices}



Definition at line 66 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a668f1a87f3c5c4776bf06c884ef344d5}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a668f1a87f3c5c4776bf06c884ef344d5}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!fill\+\_\+cache\+\_\+lock@{fill\+\_\+cache\+\_\+lock}}
\index{fill\+\_\+cache\+\_\+lock@{fill\+\_\+cache\+\_\+lock}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{fill\+\_\+cache\+\_\+lock}{fill\_cache\_lock}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+fill\+\_\+cache\+\_\+lock}



Definition at line 76 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a68076c873c29c3752c391937c2fe6adc}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a68076c873c29c3752c391937c2fe6adc}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!length\+\_\+to\+\_\+eps@{length\+\_\+to\+\_\+eps}}
\index{length\+\_\+to\+\_\+eps@{length\+\_\+to\+\_\+eps}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{length\+\_\+to\+\_\+eps}{length\_to\_eps}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+length\+\_\+to\+\_\+eps}



Definition at line 64 of file pytorch\+\_\+data\+\_\+teacher.\+py.

\mbox{\Hypertarget{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a50725d8fc600b792cd856d1ff4bdaca3}\label{classparlai_1_1core_1_1pytorch__data__teacher_1_1BatchSortCache_a50725d8fc600b792cd856d1ff4bdaca3}} 
\index{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}!load\+\_\+complete@{load\+\_\+complete}}
\index{load\+\_\+complete@{load\+\_\+complete}!parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache@{parlai\+::core\+::pytorch\+\_\+data\+\_\+teacher\+::\+Batch\+Sort\+Cache}}
\subsubsection{\texorpdfstring{load\+\_\+complete}{load\_complete}}
{\footnotesize\ttfamily parlai.\+core.\+pytorch\+\_\+data\+\_\+teacher.\+Batch\+Sort\+Cache.\+load\+\_\+complete}



Definition at line 70 of file pytorch\+\_\+data\+\_\+teacher.\+py.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
parlai/core/\hyperlink{pytorch__data__teacher_8py}{pytorch\+\_\+data\+\_\+teacher.\+py}\end{DoxyCompactItemize}
