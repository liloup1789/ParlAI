\hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager}{}\section{parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager Class Reference}
\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager}\index{parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager@{parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager}}


Inheritance diagram for parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=265pt]{da/dd4/classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=265pt]{d7/de1/classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a686dafeb3df50fdcd77271647d81dcd4}{set\+Up} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ab6ce44d19a57151491c6aa40f3c02401}{tear\+Down} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ad1abec4c7e27606a147ff5e6bd17b1bf}{test\+\_\+private\+\_\+create\+\_\+agent} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa375b82e666943c204207cc33cad34a1}{test\+\_\+agent\+\_\+task\+\_\+management} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_af0963d2895bad044ea842fb62d9a60dd}{test\+\_\+shutdown} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a433805c31fbc04c931a73a1730f0fac4}{test\+\_\+time\+\_\+blocks} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a67df06527d24aa6e0371ebe33d1d9cc5}{test\+\_\+disconnect\+\_\+management} (self)
\item 
def \hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a3e096b61b3202fea706fd54d6cbe1a9a}{test\+\_\+conversation\+\_\+management} (self)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a079143d302b581f5215cace52d6e30ad}{opt}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aed8e74630b4e4f95f00599e4cfc3058c}{mturk\+\_\+manager}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa72feb8d0d0bed3ff27b9904e052a616}{worker\+\_\+manager}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ac79288937dd4b40b9ba662d3d03cfbaf}{worker\+\_\+state\+\_\+1}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_adb3ccb63bde0ca48296d444bcd9a507b}{worker\+\_\+state\+\_\+2}
\item 
\hyperlink{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a39dccdaf12fba31599b29334ecf81ce3}{worker\+\_\+state\+\_\+3}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Various unit tests for the WorkerManager class.
\end{DoxyVerb}
 

Definition at line 133 of file test\+\_\+worker\+\_\+manager.\+py.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a686dafeb3df50fdcd77271647d81dcd4}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a686dafeb3df50fdcd77271647d81dcd4}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!set\+Up@{set\+Up}}
\index{set\+Up@{set\+Up}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{set\+Up()}{setUp()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+set\+Up (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Definition at line 138 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
138     \textcolor{keyword}{def }setUp(self):
139         disconnect\_path = os.path.join(parent\_dir, \textcolor{stringliteral}{'disconnect-test.pickle'})
140         \textcolor{keywordflow}{if} os.path.exists(disconnect\_path):
141             os.remove(disconnect\_path)
142 
143         argparser = ParlaiParser(\textcolor{keyword}{False}, \textcolor{keyword}{False})
144         argparser.add\_parlai\_data\_path()
145         argparser.add\_mturk\_args()
146         self.opt = argparser.parse\_args(print\_args=\textcolor{keyword}{False})
147         self.opt[\textcolor{stringliteral}{'task'}] = \textcolor{stringliteral}{'unittest'}
148         self.opt[\textcolor{stringliteral}{'assignment\_duration\_in\_seconds'}] = 6
149         mturk\_agent\_ids = [\textcolor{stringliteral}{'mturk\_agent\_1'}]
150         self.mturk\_manager = MTurkManager(
151             opt=self.opt.copy(), mturk\_agent\_ids=mturk\_agent\_ids
152         )
153         self.worker\_manager = self.mturk\_manager.worker\_manager
154         self.mturk\_manager.send\_message = mock.MagicMock()
155         self.mturk\_manager.send\_state\_change = mock.MagicMock()
156         self.mturk\_manager.send\_command = mock.MagicMock()
157 
158         self.worker\_state\_1 = self.worker\_manager.worker\_alive(TEST\_WORKER\_ID\_1)
159         self.worker\_state\_2 = self.worker\_manager.worker\_alive(TEST\_WORKER\_ID\_2)
160         self.worker\_state\_3 = self.worker\_manager.worker\_alive(TEST\_WORKER\_ID\_3)
161 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ab6ce44d19a57151491c6aa40f3c02401}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ab6ce44d19a57151491c6aa40f3c02401}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!tear\+Down@{tear\+Down}}
\index{tear\+Down@{tear\+Down}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{tear\+Down()}{tearDown()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+tear\+Down (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Definition at line 162 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
162     \textcolor{keyword}{def }tearDown(self):
163         self.mturk\_manager.shutdown()
164 
165         disconnect\_path = os.path.join(parent\_dir, \textcolor{stringliteral}{'disconnect-test.pickle'})
166         \textcolor{keywordflow}{if} os.path.exists(disconnect\_path):
167             os.remove(disconnect\_path)
168 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa375b82e666943c204207cc33cad34a1}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa375b82e666943c204207cc33cad34a1}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+agent\+\_\+task\+\_\+management@{test\+\_\+agent\+\_\+task\+\_\+management}}
\index{test\+\_\+agent\+\_\+task\+\_\+management@{test\+\_\+agent\+\_\+task\+\_\+management}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+agent\+\_\+task\+\_\+management()}{test\_agent\_task\_management()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+agent\+\_\+task\+\_\+management (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Ensure agents and tasks have proper bookkeeping.
\end{DoxyVerb}
 

Definition at line 181 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
181     \textcolor{keyword}{def }test\_agent\_task\_management(self):
182         \textcolor{stringliteral}{"""}
183 \textcolor{stringliteral}{        Ensure agents and tasks have proper bookkeeping.}
184 \textcolor{stringliteral}{        """}
185         self.worker\_manager.assign\_task\_to\_worker(
186             TEST\_HIT\_ID\_1, TEST\_ASSIGNMENT\_ID\_1, TEST\_WORKER\_ID\_1
187         )
188         self.worker\_manager.assign\_task\_to\_worker(
189             TEST\_HIT\_ID\_2, TEST\_ASSIGNMENT\_ID\_2, TEST\_WORKER\_ID\_2
190         )
191         self.worker\_manager.assign\_task\_to\_worker(
192             TEST\_HIT\_ID\_3, TEST\_ASSIGNMENT\_ID\_3, TEST\_WORKER\_ID\_1
193         )
194         self.assertTrue(self.worker\_state\_1.has\_assignment(TEST\_ASSIGNMENT\_ID\_1))
195         self.assertTrue(self.worker\_state\_1.has\_assignment(TEST\_ASSIGNMENT\_ID\_3))
196         self.assertTrue(self.worker\_state\_2.has\_assignment(TEST\_ASSIGNMENT\_ID\_2))
197 
198         assign\_agent = self.worker\_manager.get\_agent\_for\_assignment(
199             TEST\_ASSIGNMENT\_ID\_1
200         )
201         self.assertEqual(assign\_agent.worker\_id, TEST\_WORKER\_ID\_1)
202         self.assertEqual(assign\_agent.hit\_id, TEST\_HIT\_ID\_1)
203         self.assertEqual(assign\_agent.assignment\_id, TEST\_ASSIGNMENT\_ID\_1)
204 
205         no\_such\_agent = self.worker\_manager.get\_agent\_for\_assignment(FAKE\_ID)
206         self.assertIsNone(no\_such\_agent)
207 
208         \textcolor{comment}{# Ensure all agents are being maintained}
209         checked\_count = 0
210         filtered\_count = 0
211 
212         \textcolor{keyword}{def }check\_is\_worker\_1(agent):
213             nonlocal checked\_count  \textcolor{comment}{# noqa E999 python 3 only}
214             checked\_count += 1
215             self.assertEqual(agent.worker\_id, TEST\_WORKER\_ID\_1)
216 
217         \textcolor{keyword}{def }is\_worker\_1(agent):
218             nonlocal filtered\_count
219             filtered\_count += 1
220             \textcolor{keywordflow}{return} agent.worker\_id == TEST\_WORKER\_ID\_1
221 
222         self.worker\_manager.map\_over\_agents(check\_is\_worker\_1, is\_worker\_1)
223         self.assertEqual(checked\_count, 2)
224         self.assertEqual(filtered\_count, 3)
225 
226         \textcolor{comment}{# Ensuring \_get\_worker is accurate}
227         self.assertEqual(
228             self.worker\_manager.\_get\_worker(TEST\_WORKER\_ID\_1), self.worker\_state\_1
229         )
230         self.assertEqual(
231             self.worker\_manager.\_get\_worker(TEST\_WORKER\_ID\_2), self.worker\_state\_2
232         )
233         self.assertEqual(
234             self.worker\_manager.\_get\_worker(TEST\_WORKER\_ID\_3), self.worker\_state\_3
235         )
236         self.assertIsNone(self.worker\_manager.\_get\_worker(FAKE\_ID))
237 
238         \textcolor{comment}{# Ensuring \_get\_agent is accurate}
239         self.assertEqual(
240             self.worker\_manager.\_get\_agent(TEST\_WORKER\_ID\_1, TEST\_ASSIGNMENT\_ID\_1),
241             self.worker\_manager.get\_agent\_for\_assignment(TEST\_ASSIGNMENT\_ID\_1),
242         )
243         self.assertNotEqual(
244             self.worker\_manager.\_get\_agent(TEST\_WORKER\_ID\_1, TEST\_ASSIGNMENT\_ID\_2),
245             self.worker\_manager.get\_agent\_for\_assignment(TEST\_ASSIGNMENT\_ID\_2),
246         )
247 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a3e096b61b3202fea706fd54d6cbe1a9a}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a3e096b61b3202fea706fd54d6cbe1a9a}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+conversation\+\_\+management@{test\+\_\+conversation\+\_\+management}}
\index{test\+\_\+conversation\+\_\+management@{test\+\_\+conversation\+\_\+management}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+conversation\+\_\+management()}{test\_conversation\_management()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+conversation\+\_\+management (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tests handling conversation state, moving agents to the correct conversations,
and disconnecting one worker in an active convo.
\end{DoxyVerb}
 

Definition at line 361 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
361     \textcolor{keyword}{def }test\_conversation\_management(self):
362         \textcolor{stringliteral}{"""}
363 \textcolor{stringliteral}{        Tests handling conversation state, moving agents to the correct conversations,}
364 \textcolor{stringliteral}{        and disconnecting one worker in an active convo.}
365 \textcolor{stringliteral}{        """}
366         self.worker\_manager.assign\_task\_to\_worker(
367             TEST\_HIT\_ID\_1, TEST\_ASSIGNMENT\_ID\_1, TEST\_WORKER\_ID\_1
368         )
369         self.worker\_manager.assign\_task\_to\_worker(
370             TEST\_HIT\_ID\_2, TEST\_ASSIGNMENT\_ID\_2, TEST\_WORKER\_ID\_2
371         )
372 
373         good\_agent = self.worker\_manager.get\_agent\_for\_assignment(TEST\_ASSIGNMENT\_ID\_1)
374         bad\_agent = self.worker\_manager.get\_agent\_for\_assignment(TEST\_ASSIGNMENT\_ID\_2)
375 
376         \textcolor{keyword}{def }fake\_command\_send(worker\_id, assignment\_id, data, ack\_func):
377             pkt = mock.MagicMock()
378             pkt.sender\_id = worker\_id
379             pkt.assignment\_id = assignment\_id
380             self.assertEqual(data[\textcolor{stringliteral}{'text'}], data\_model.COMMAND\_CHANGE\_CONVERSATION)
381             ack\_func(pkt)
382 
383         self.mturk\_manager.send\_command = fake\_command\_send
384         good\_agent.set\_status(
385             AssignState.STATUS\_IN\_TASK, conversation\_id=\textcolor{stringliteral}{'t1'}, agent\_id=\textcolor{stringliteral}{'good'}
386         )
387         bad\_agent.set\_status(
388             AssignState.STATUS\_IN\_TASK, conversation\_id=\textcolor{stringliteral}{'t1'}, agent\_id=\textcolor{stringliteral}{'bad'}
389         )
390         self.assertEqual(good\_agent.id, \textcolor{stringliteral}{'good'})
391         self.assertEqual(bad\_agent.id, \textcolor{stringliteral}{'bad'})
392         self.assertEqual(good\_agent.conversation\_id, \textcolor{stringliteral}{'t1'})
393         self.assertEqual(bad\_agent.conversation\_id, \textcolor{stringliteral}{'t1'})
394         self.assertIn(\textcolor{stringliteral}{'t1'}, self.worker\_manager.conv\_to\_agent)
395         self.assertEqual(len(self.worker\_manager.conv\_to\_agent[\textcolor{stringliteral}{'t1'}]), 2)
396         self.worker\_manager.handle\_bad\_disconnect = mock.MagicMock()
397 
398         checked\_worker = \textcolor{keyword}{False}
399 
400         \textcolor{keyword}{def }partner\_callback(agent):
401             nonlocal checked\_worker
402             checked\_worker = \textcolor{keyword}{True}
403             self.assertEqual(agent.worker\_id, good\_agent.worker\_id)
404 
405         self.worker\_manager.handle\_agent\_disconnect(
406             bad\_agent.worker\_id, bad\_agent.assignment\_id, partner\_callback
407         )
408         self.assertTrue(checked\_worker)
409         self.worker\_manager.handle\_bad\_disconnect.assert\_called\_once\_with(
410             bad\_agent.worker\_id
411         )
412         self.assertEqual(bad\_agent.get\_status(), AssignState.STATUS\_DISCONNECT)
413 
414 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a67df06527d24aa6e0371ebe33d1d9cc5}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a67df06527d24aa6e0371ebe33d1d9cc5}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+disconnect\+\_\+management@{test\+\_\+disconnect\+\_\+management}}
\index{test\+\_\+disconnect\+\_\+management@{test\+\_\+disconnect\+\_\+management}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+disconnect\+\_\+management()}{test\_disconnect\_management()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+disconnect\+\_\+management (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Definition at line 308 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
308     \textcolor{keyword}{def }test\_disconnect\_management(self):
309         self.worker\_manager.load\_disconnects()
310         self.worker\_manager.is\_sandbox = \textcolor{keyword}{False}
311         self.mturk\_manager.block\_worker = mock.MagicMock()
312         self.mturk\_manager.soft\_block\_worker = mock.MagicMock()
313 
314         self.assertEqual(len(self.worker\_manager.disconnects), 0)
315         \textcolor{comment}{# Make one worker disconnect twice}
316         self.worker\_manager.handle\_bad\_disconnect(TEST\_WORKER\_ID\_1)
317         self.assertEqual(len(self.worker\_manager.disconnects), 1)
318         self.mturk\_manager.block\_worker.assert\_not\_called()
319         self.mturk\_manager.soft\_block\_worker.assert\_not\_called()
320         self.worker\_manager.handle\_bad\_disconnect(TEST\_WORKER\_ID\_1)
321         self.assertEqual(len(self.worker\_manager.disconnects), 2)
322         self.mturk\_manager.block\_worker.assert\_not\_called()
323         self.mturk\_manager.soft\_block\_worker.assert\_not\_called()
324 
325         \textcolor{comment}{# Ensure both disconnects recorded}
326         self.assertEqual(
327             self.worker\_manager.mturk\_workers[TEST\_WORKER\_ID\_1].disconnects, 2
328         )
329 
330         \textcolor{comment}{# Make second worker disconnect}
331         self.worker\_manager.handle\_bad\_disconnect(TEST\_WORKER\_ID\_2)
332         self.assertEqual(len(self.worker\_manager.disconnects), 3)
333         self.mturk\_manager.block\_worker.assert\_not\_called()
334         self.mturk\_manager.soft\_block\_worker.assert\_not\_called()
335 
336         \textcolor{comment}{# Make us soft block workers on disconnect}
337         self.worker\_manager.opt[\textcolor{stringliteral}{'disconnect\_qualification'}] = \textcolor{stringliteral}{'test'}
338         self.worker\_manager.handle\_bad\_disconnect(TEST\_WORKER\_ID\_1)
339         self.mturk\_manager.block\_worker.assert\_not\_called()
340         self.mturk\_manager.soft\_block\_worker.assert\_called\_with(
341             TEST\_WORKER\_ID\_1, \textcolor{stringliteral}{'disconnect\_qualification'}
342         )
343         self.mturk\_manager.soft\_block\_worker.reset\_mock()
344 
345         \textcolor{comment}{# Make us now block workers on disconnect}
346         self.worker\_manager.opt[\textcolor{stringliteral}{'hard\_block'}] = \textcolor{keyword}{True}
347         self.worker\_manager.handle\_bad\_disconnect(TEST\_WORKER\_ID\_2)
348         self.mturk\_manager.block\_worker.assert\_called\_once()
349         self.mturk\_manager.soft\_block\_worker.assert\_not\_called()
350 
351         \textcolor{comment}{# Ensure we can save and reload disconnects}
352         self.worker\_manager.save\_disconnects()
353 
354         \textcolor{comment}{# Make a new worker manager}
355         worker\_manager2 = WorkerManager(self.mturk\_manager, self.opt)
356         self.assertEqual(len(worker\_manager2.disconnects), 5)
357         self.assertEqual(worker\_manager2.mturk\_workers[TEST\_WORKER\_ID\_1].disconnects, 3)
358         self.assertEqual(worker\_manager2.mturk\_workers[TEST\_WORKER\_ID\_2].disconnects, 2)
359         worker\_manager2.shutdown()
360 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ad1abec4c7e27606a147ff5e6bd17b1bf}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ad1abec4c7e27606a147ff5e6bd17b1bf}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+private\+\_\+create\+\_\+agent@{test\+\_\+private\+\_\+create\+\_\+agent}}
\index{test\+\_\+private\+\_\+create\+\_\+agent@{test\+\_\+private\+\_\+create\+\_\+agent}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+private\+\_\+create\+\_\+agent()}{test\_private\_create\_agent()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+private\+\_\+create\+\_\+agent (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check create agent method used internally in worker_manager.
\end{DoxyVerb}
 

Definition at line 169 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
169     \textcolor{keyword}{def }test\_private\_create\_agent(self):
170         \textcolor{stringliteral}{"""}
171 \textcolor{stringliteral}{        Check create agent method used internally in worker\_manager.}
172 \textcolor{stringliteral}{        """}
173         test\_agent = self.worker\_manager.\_create\_agent(
174             TEST\_HIT\_ID\_1, TEST\_ASSIGNMENT\_ID\_1, TEST\_WORKER\_ID\_1
175         )
176         self.assertIsInstance(test\_agent, MTurkAgent)
177         self.assertEqual(test\_agent.worker\_id, TEST\_WORKER\_ID\_1)
178         self.assertEqual(test\_agent.hit\_id, TEST\_HIT\_ID\_1)
179         self.assertEqual(test\_agent.assignment\_id, TEST\_ASSIGNMENT\_ID\_1)
180 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_af0963d2895bad044ea842fb62d9a60dd}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_af0963d2895bad044ea842fb62d9a60dd}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+shutdown@{test\+\_\+shutdown}}
\index{test\+\_\+shutdown@{test\+\_\+shutdown}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+shutdown()}{test\_shutdown()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+shutdown (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Ensure shutdown clears required resources.
\end{DoxyVerb}
 

Definition at line 248 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
248     \textcolor{keyword}{def }test\_shutdown(self):
249         \textcolor{stringliteral}{"""}
250 \textcolor{stringliteral}{        Ensure shutdown clears required resources.}
251 \textcolor{stringliteral}{        """}
252         self.worker\_manager.save\_disconnects = mock.MagicMock()
253         self.worker\_manager.un\_time\_block\_workers = mock.MagicMock()
254         self.worker\_manager.shutdown()
255         self.assertEqual(
256             len(self.worker\_manager.save\_disconnects.mock\_calls),
257             1,
258             \textcolor{stringliteral}{'save\_disconnects must be called in worker manager shutdown'},
259         )
260         self.assertEqual(
261             len(self.worker\_manager.un\_time\_block\_workers.mock\_calls),
262             1,
263             \textcolor{stringliteral}{'un\_time\_block\_workers must be called in worker manager shutdown'},
264         )
265 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a433805c31fbc04c931a73a1730f0fac4}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a433805c31fbc04c931a73a1730f0fac4}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!test\+\_\+time\+\_\+blocks@{test\+\_\+time\+\_\+blocks}}
\index{test\+\_\+time\+\_\+blocks@{test\+\_\+time\+\_\+blocks}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{test\+\_\+time\+\_\+blocks()}{test\_time\_blocks()}}
{\footnotesize\ttfamily def parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+test\+\_\+time\+\_\+blocks (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check to see if time blocking and clearing works.
\end{DoxyVerb}
 

Definition at line 266 of file test\+\_\+worker\+\_\+manager.\+py.


\begin{DoxyCode}
266     \textcolor{keyword}{def }test\_time\_blocks(self):
267         \textcolor{stringliteral}{"""}
268 \textcolor{stringliteral}{        Check to see if time blocking and clearing works.}
269 \textcolor{stringliteral}{        """}
270         self.mturk\_manager.soft\_block\_worker = mock.MagicMock()
271         self.mturk\_manager.un\_soft\_block\_worker = mock.MagicMock()
272 
273         \textcolor{comment}{# No workers blocked, none should be unblocked}
274         self.worker\_manager.un\_time\_block\_workers()
275         self.assertEqual(len(self.mturk\_manager.un\_soft\_block\_worker.mock\_calls), 0)
276 
277         \textcolor{comment}{# Block some workers, ensure state change and correct calls}
278         self.assertEqual(len(self.worker\_manager.time\_blocked\_workers), 0)
279         self.worker\_manager.time\_block\_worker(TEST\_WORKER\_ID\_1)
280         self.mturk\_manager.soft\_block\_worker.assert\_called\_with(
281             TEST\_WORKER\_ID\_1, \textcolor{stringliteral}{'max\_time\_qual'}
282         )
283         self.assertEqual(len(self.worker\_manager.time\_blocked\_workers), 1)
284         self.worker\_manager.time\_block\_worker(TEST\_WORKER\_ID\_2)
285         self.mturk\_manager.soft\_block\_worker.assert\_called\_with(
286             TEST\_WORKER\_ID\_2, \textcolor{stringliteral}{'max\_time\_qual'}
287         )
288         self.assertEqual(len(self.worker\_manager.time\_blocked\_workers), 2)
289         self.assertEqual(len(self.mturk\_manager.soft\_block\_worker.mock\_calls), 2)
290 
291         \textcolor{comment}{# Unblock a worker passed in as a keyword arg, ensure state remains}
292         self.worker\_manager.un\_time\_block\_workers([TEST\_WORKER\_ID\_3])
293         self.mturk\_manager.un\_soft\_block\_worker.assert\_called\_with(
294             TEST\_WORKER\_ID\_3, \textcolor{stringliteral}{'max\_time\_qual'}
295         )
296         self.assertEqual(len(self.worker\_manager.time\_blocked\_workers), 2)
297 
298         \textcolor{comment}{# Unblock blocked workers, ensure proper calls and state change}
299         self.worker\_manager.un\_time\_block\_workers()
300         self.assertEqual(len(self.worker\_manager.time\_blocked\_workers), 0)
301         self.mturk\_manager.un\_soft\_block\_worker.assert\_any\_call(
302             TEST\_WORKER\_ID\_1, \textcolor{stringliteral}{'max\_time\_qual'}
303         )
304         self.mturk\_manager.un\_soft\_block\_worker.assert\_any\_call(
305             TEST\_WORKER\_ID\_2, \textcolor{stringliteral}{'max\_time\_qual'}
306         )
307 
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aed8e74630b4e4f95f00599e4cfc3058c}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aed8e74630b4e4f95f00599e4cfc3058c}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!mturk\+\_\+manager@{mturk\+\_\+manager}}
\index{mturk\+\_\+manager@{mturk\+\_\+manager}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{mturk\+\_\+manager}{mturk\_manager}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+mturk\+\_\+manager}



Definition at line 150 of file test\+\_\+worker\+\_\+manager.\+py.

\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a079143d302b581f5215cace52d6e30ad}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a079143d302b581f5215cace52d6e30ad}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!opt@{opt}}
\index{opt@{opt}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{opt}{opt}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+opt}



Definition at line 146 of file test\+\_\+worker\+\_\+manager.\+py.

\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa72feb8d0d0bed3ff27b9904e052a616}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_aa72feb8d0d0bed3ff27b9904e052a616}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!worker\+\_\+manager@{worker\+\_\+manager}}
\index{worker\+\_\+manager@{worker\+\_\+manager}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{worker\+\_\+manager}{worker\_manager}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+worker\+\_\+manager}



Definition at line 153 of file test\+\_\+worker\+\_\+manager.\+py.

\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ac79288937dd4b40b9ba662d3d03cfbaf}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_ac79288937dd4b40b9ba662d3d03cfbaf}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!worker\+\_\+state\+\_\+1@{worker\+\_\+state\+\_\+1}}
\index{worker\+\_\+state\+\_\+1@{worker\+\_\+state\+\_\+1}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{worker\+\_\+state\+\_\+1}{worker\_state\_1}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+worker\+\_\+state\+\_\+1}



Definition at line 158 of file test\+\_\+worker\+\_\+manager.\+py.

\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_adb3ccb63bde0ca48296d444bcd9a507b}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_adb3ccb63bde0ca48296d444bcd9a507b}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!worker\+\_\+state\+\_\+2@{worker\+\_\+state\+\_\+2}}
\index{worker\+\_\+state\+\_\+2@{worker\+\_\+state\+\_\+2}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{worker\+\_\+state\+\_\+2}{worker\_state\_2}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+worker\+\_\+state\+\_\+2}



Definition at line 159 of file test\+\_\+worker\+\_\+manager.\+py.

\mbox{\Hypertarget{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a39dccdaf12fba31599b29334ecf81ce3}\label{classparlai_1_1mturk_1_1core_1_1dev_1_1test_1_1test__worker__manager_1_1TestWorkerManager_a39dccdaf12fba31599b29334ecf81ce3}} 
\index{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}!worker\+\_\+state\+\_\+3@{worker\+\_\+state\+\_\+3}}
\index{worker\+\_\+state\+\_\+3@{worker\+\_\+state\+\_\+3}!parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager@{parlai\+::mturk\+::core\+::dev\+::test\+::test\+\_\+worker\+\_\+manager\+::\+Test\+Worker\+Manager}}
\subsubsection{\texorpdfstring{worker\+\_\+state\+\_\+3}{worker\_state\_3}}
{\footnotesize\ttfamily parlai.\+mturk.\+core.\+dev.\+test.\+test\+\_\+worker\+\_\+manager.\+Test\+Worker\+Manager.\+worker\+\_\+state\+\_\+3}



Definition at line 160 of file test\+\_\+worker\+\_\+manager.\+py.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
parlai/mturk/core/dev/test/\hyperlink{dev_2test_2test__worker__manager_8py}{test\+\_\+worker\+\_\+manager.\+py}\end{DoxyCompactItemize}
