\hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils}{}\section{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils Class Reference}
\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils}\index{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils@{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils}}


Inheritance diagram for parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=192pt]{d3/d2b/classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=192pt]{d6/d95/classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}{pad\+\_\+text} (cls, observations, dictionary, end\+\_\+idx=None, null\+\_\+idx=0, dq=False, eval\+\_\+labels=True, truncate=None)
\item 
def \hyperlink{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}{map\+\_\+predictions} (cls, predictions, valid\+\_\+inds, batch\+\_\+reply, observations, dictionary, end\+\_\+idx, report\+\_\+freq=0.\+1, labels=None, answers=None, ys=None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Class that contains functions that help with padding input and target tensors.
\end{DoxyVerb}
 

Definition at line 414 of file utils\+\_\+v0.\+py.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}} 
\index{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}!map\+\_\+predictions@{map\+\_\+predictions}}
\index{map\+\_\+predictions@{map\+\_\+predictions}!parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}}
\subsubsection{\texorpdfstring{map\+\_\+predictions()}{map\_predictions()}}
{\footnotesize\ttfamily def parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils.\+map\+\_\+predictions (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{predictions,  }\item[{}]{valid\+\_\+inds,  }\item[{}]{batch\+\_\+reply,  }\item[{}]{observations,  }\item[{}]{dictionary,  }\item[{}]{end\+\_\+idx,  }\item[{}]{report\+\_\+freq = {\ttfamily 0.1},  }\item[{}]{labels = {\ttfamily None},  }\item[{}]{answers = {\ttfamily None},  }\item[{}]{ys = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Predictions are mapped back to appropriate indices in the batch_reply using
valid_inds.

report_freq -- how often we report predictions
\end{DoxyVerb}
 

Definition at line 553 of file utils\+\_\+v0.\+py.


\begin{DoxyCode}
553     ):
554         \textcolor{stringliteral}{"""}
555 \textcolor{stringliteral}{        Predictions are mapped back to appropriate indices in the batch\_reply using}
556 \textcolor{stringliteral}{        valid\_inds.}
557 \textcolor{stringliteral}{}
558 \textcolor{stringliteral}{        report\_freq -- how often we report predictions}
559 \textcolor{stringliteral}{        """}
560         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(len(predictions)):
561             \textcolor{comment}{# map the predictions back to non-empty examples in the batch}
562             \textcolor{comment}{# we join with spaces since we produce tokens one at a timelab}
563             curr = batch\_reply[valid\_inds[i]]
564             output\_tokens = []
565             j = 0
566             \textcolor{keywordflow}{for} c \textcolor{keywordflow}{in} predictions[i]:
567                 \textcolor{keywordflow}{if} c == end\_idx \textcolor{keywordflow}{and} j != 0:
568                     \textcolor{keywordflow}{break}
569                 \textcolor{keywordflow}{else}:
570                     output\_tokens.append(c)
571                 j += 1
572             curr\_pred = dictionary.vec2txt(output\_tokens)
573             curr[\textcolor{stringliteral}{'text'}] = curr\_pred
574 
575             \textcolor{keywordflow}{if} labels \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} answers \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} ys \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
576                 y = []
577                 \textcolor{keywordflow}{for} c \textcolor{keywordflow}{in} ys[i]:
578                     \textcolor{keywordflow}{if} c == end\_idx:
579                         \textcolor{keywordflow}{break}
580                     \textcolor{keywordflow}{else}:
581                         y.append(c)
582                 answers[valid\_inds[i]] = y
583             \textcolor{keywordflow}{elif} answers \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
584                 answers[valid\_inds[i]] = curr\_pred
585 
586             \textcolor{keywordflow}{if} random.random() > (1 - report\_freq):
587                 \textcolor{comment}{# log sometimes}
588                 print(\textcolor{stringliteral}{'TEXT: '}, observations[valid\_inds[i]][\textcolor{stringliteral}{'text'}])
589                 print(\textcolor{stringliteral}{'PREDICTION: '}, curr\_pred, \textcolor{stringliteral}{'\(\backslash\)n~'})
590         \textcolor{keywordflow}{return}
591 
592 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}} 
\index{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}!pad\+\_\+text@{pad\+\_\+text}}
\index{pad\+\_\+text@{pad\+\_\+text}!parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}}
\subsubsection{\texorpdfstring{pad\+\_\+text()}{pad\_text()}}
{\footnotesize\ttfamily def parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils.\+pad\+\_\+text (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{observations,  }\item[{}]{dictionary,  }\item[{}]{end\+\_\+idx = {\ttfamily None},  }\item[{}]{null\+\_\+idx = {\ttfamily 0},  }\item[{}]{dq = {\ttfamily False},  }\item[{}]{eval\+\_\+labels = {\ttfamily True},  }\item[{}]{truncate = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}We check that examples are valid, pad with zeros, and sort by length so that we
can use the pack_padded function.

The list valid_inds
keeps track of which indices are valid and the order in which we sort
the examples.
dq -- whether we should use deque or list
eval_labels -- whether or not we want to consider eval labels
truncate -- truncate input and output lengths
\end{DoxyVerb}
 

Definition at line 429 of file utils\+\_\+v0.\+py.


\begin{DoxyCode}
429     ):
430         \textcolor{stringliteral}{"""}
431 \textcolor{stringliteral}{        We check that examples are valid, pad with zeros, and sort by length so that we}
432 \textcolor{stringliteral}{        can use the pack\_padded function.}
433 \textcolor{stringliteral}{}
434 \textcolor{stringliteral}{        The list valid\_inds}
435 \textcolor{stringliteral}{        keeps track of which indices are valid and the order in which we sort}
436 \textcolor{stringliteral}{        the examples.}
437 \textcolor{stringliteral}{        dq -- whether we should use deque or list}
438 \textcolor{stringliteral}{        eval\_labels -- whether or not we want to consider eval labels}
439 \textcolor{stringliteral}{        truncate -- truncate input and output lengths}
440 \textcolor{stringliteral}{        """}
441 
442         \textcolor{keyword}{def }valid(obs):
443             \textcolor{comment}{# check if this is an example our model should actually process}
444             \textcolor{keywordflow}{return} \textcolor{stringliteral}{'text'} \textcolor{keywordflow}{in} obs \textcolor{keywordflow}{and} len(obs[\textcolor{stringliteral}{'text'}]) > 0
445 
446         \textcolor{keywordflow}{try}:
447             \textcolor{comment}{# valid examples and their indices}
448             valid\_inds, exs = zip(
449                 *[(i, ex) \textcolor{keywordflow}{for} i, ex \textcolor{keywordflow}{in} enumerate(observations) \textcolor{keywordflow}{if} valid(ex)]
450             )
451         \textcolor{keywordflow}{except} ValueError:
452             \textcolor{comment}{# zero examples to process in this batch, so zip failed to unpack}
453             \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}
454 
455         \textcolor{comment}{# `x` text is already tokenized and truncated}
456         \textcolor{comment}{# sort by length so we can use pack\_padded}
457         \textcolor{keywordflow}{if} any([\textcolor{stringliteral}{'text2vec'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]):
458             parsed\_x = [ex[\textcolor{stringliteral}{'text2vec'}] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
459         \textcolor{keywordflow}{else}:
460             parsed\_x = [dictionary.txt2vec(ex[\textcolor{stringliteral}{'text'}]) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
461 
462         \textcolor{keywordflow}{if} len(parsed\_x) > 0 \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} isinstance(parsed\_x[0], deque):
463             \textcolor{keywordflow}{if} dq:
464                 parsed\_x = [deque(x, maxlen=truncate) \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
465             \textcolor{keywordflow}{elif} truncate \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} truncate > 0:
466                 parsed\_x = [x[-truncate:] \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
467 
468         x\_lens = [len(x) \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
469         ind\_sorted = sorted(range(len(x\_lens)), key=\textcolor{keyword}{lambda} k: -x\_lens[k])
470 
471         exs = [exs[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
472         valid\_inds = [valid\_inds[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
473         parsed\_x = [parsed\_x[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
474         end\_idxs = [x\_lens[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
475 
476         eval\_labels\_avail = any([\textcolor{stringliteral}{'eval\_labels'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs])
477         labels\_avail = any([\textcolor{stringliteral}{'labels'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs])
478         \textcolor{keywordflow}{if} eval\_labels:
479             some\_labels\_avail = eval\_labels\_avail \textcolor{keywordflow}{or} labels\_avail
480         \textcolor{keywordflow}{else}:
481             some\_labels\_avail = labels\_avail
482 
483         max\_x\_len = max(x\_lens)
484 
485         \textcolor{comment}{# pad with zeros}
486         \textcolor{keywordflow}{if} dq:
487             parsed\_x = [
488                 x
489                 \textcolor{keywordflow}{if} len(x) == max\_x\_len
490                 \textcolor{keywordflow}{else} x + deque((null\_idx,)) * (max\_x\_len - len(x))
491                 \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x
492             ]
493         \textcolor{keywordflow}{else}:
494             parsed\_x = [
495                 x \textcolor{keywordflow}{if} len(x) == max\_x\_len \textcolor{keywordflow}{else} x + [null\_idx] * (max\_x\_len - len(x))
496                 \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x
497             ]
498         xs = parsed\_x
499 
500         \textcolor{comment}{# set up the target tensors}
501         ys = \textcolor{keywordtype}{None}
502         labels = \textcolor{keywordtype}{None}
503         y\_lens = \textcolor{keywordtype}{None}
504         \textcolor{keywordflow}{if} some\_labels\_avail:
505             \textcolor{comment}{# randomly select one of the labels to update on (if multiple)}
506             \textcolor{keywordflow}{if} labels\_avail:
507                 labels = [random.choice(ex.get(\textcolor{stringliteral}{'labels'}, [\textcolor{stringliteral}{''}])) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
508             \textcolor{keywordflow}{else}:
509                 labels = [random.choice(ex.get(\textcolor{stringliteral}{'eval\_labels'}, [\textcolor{stringliteral}{''}])) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
510             \textcolor{comment}{# parse each label and append END}
511             \textcolor{keywordflow}{if} dq:
512                 parsed\_y = [deque(maxlen=truncate) \textcolor{keywordflow}{for} \_ \textcolor{keywordflow}{in} labels]
513                 \textcolor{keywordflow}{for} deq, y \textcolor{keywordflow}{in} zip(parsed\_y, labels):
514                     deq.extendleft(reversed(dictionary.txt2vec(y)))
515             \textcolor{keywordflow}{else}:
516                 parsed\_y = [dictionary.txt2vec(label) \textcolor{keywordflow}{for} label \textcolor{keywordflow}{in} labels]
517             \textcolor{keywordflow}{if} end\_idx \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
518                 \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y:
519                     y.append(end\_idx)
520 
521             y\_lens = [len(y) \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y]
522             max\_y\_len = max(y\_lens)
523 
524             \textcolor{keywordflow}{if} dq:
525                 parsed\_y = [
526                     y
527                     \textcolor{keywordflow}{if} len(y) == max\_y\_len
528                     \textcolor{keywordflow}{else} y + deque((null\_idx,)) * (max\_y\_len - len(y))
529                     \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y
530                 ]
531             \textcolor{keywordflow}{else}:
532                 parsed\_y = [
533                     y \textcolor{keywordflow}{if} len(y) == max\_y\_len \textcolor{keywordflow}{else} y + [null\_idx] * (max\_y\_len - len(y))
534                     \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y
535                 ]
536             ys = parsed\_y
537 
538         \textcolor{keywordflow}{return} xs, ys, labels, valid\_inds, end\_idxs, y\_lens
539 
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
parlai/agents/legacy\+\_\+agents/seq2seq/\hyperlink{utils__v0_8py}{utils\+\_\+v0.\+py}\end{DoxyCompactItemize}
