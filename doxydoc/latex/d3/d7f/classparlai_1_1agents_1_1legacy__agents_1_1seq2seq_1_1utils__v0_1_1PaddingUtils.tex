\hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils}{}\section{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils Class Reference}
\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils}\index{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils@{parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils}}


Inheritance diagram for parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=192pt]{d3/d2b/classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=192pt]{d6/d95/classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}{pad\+\_\+text} (cls, observations, dictionary, end\+\_\+idx=None, null\+\_\+idx=0, dq=False, eval\+\_\+labels=True, truncate=None)
\item 
def \hyperlink{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}{map\+\_\+predictions} (cls, predictions, valid\+\_\+inds, batch\+\_\+reply, observations, dictionary, end\+\_\+idx, report\+\_\+freq=0.\+1, labels=None, answers=None, ys=None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Class that contains functions that help with padding input and target tensors.
\end{DoxyVerb}
 

Definition at line 415 of file utils\+\_\+v0.\+py.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae2c46f2f424e4301873e1c5bc201646c}} 
\index{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}!map\+\_\+predictions@{map\+\_\+predictions}}
\index{map\+\_\+predictions@{map\+\_\+predictions}!parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}}
\subsubsection{\texorpdfstring{map\+\_\+predictions()}{map\_predictions()}}
{\footnotesize\ttfamily def parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils.\+map\+\_\+predictions (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{predictions,  }\item[{}]{valid\+\_\+inds,  }\item[{}]{batch\+\_\+reply,  }\item[{}]{observations,  }\item[{}]{dictionary,  }\item[{}]{end\+\_\+idx,  }\item[{}]{report\+\_\+freq = {\ttfamily 0.1},  }\item[{}]{labels = {\ttfamily None},  }\item[{}]{answers = {\ttfamily None},  }\item[{}]{ys = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Predictions are mapped back to appropriate indices in the batch_reply using
valid_inds.

report_freq -- how often we report predictions
\end{DoxyVerb}
 

Definition at line 554 of file utils\+\_\+v0.\+py.


\begin{DoxyCode}
554     ):
555         \textcolor{stringliteral}{"""}
556 \textcolor{stringliteral}{        Predictions are mapped back to appropriate indices in the batch\_reply using}
557 \textcolor{stringliteral}{        valid\_inds.}
558 \textcolor{stringliteral}{}
559 \textcolor{stringliteral}{        report\_freq -- how often we report predictions}
560 \textcolor{stringliteral}{        """}
561         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} range(len(predictions)):
562             \textcolor{comment}{# map the predictions back to non-empty examples in the batch}
563             \textcolor{comment}{# we join with spaces since we produce tokens one at a timelab}
564             curr = batch\_reply[valid\_inds[i]]
565             output\_tokens = []
566             j = 0
567             \textcolor{keywordflow}{for} c \textcolor{keywordflow}{in} predictions[i]:
568                 \textcolor{keywordflow}{if} c == end\_idx \textcolor{keywordflow}{and} j != 0:
569                     \textcolor{keywordflow}{break}
570                 \textcolor{keywordflow}{else}:
571                     output\_tokens.append(c)
572                 j += 1
573             curr\_pred = dictionary.vec2txt(output\_tokens)
574             curr[\textcolor{stringliteral}{'text'}] = curr\_pred
575 
576             \textcolor{keywordflow}{if} labels \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} answers \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} ys \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
577                 y = []
578                 \textcolor{keywordflow}{for} c \textcolor{keywordflow}{in} ys[i]:
579                     \textcolor{keywordflow}{if} c == end\_idx:
580                         \textcolor{keywordflow}{break}
581                     \textcolor{keywordflow}{else}:
582                         y.append(c)
583                 answers[valid\_inds[i]] = y
584             \textcolor{keywordflow}{elif} answers \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
585                 answers[valid\_inds[i]] = curr\_pred
586 
587             \textcolor{keywordflow}{if} random.random() > (1 - report\_freq):
588                 \textcolor{comment}{# log sometimes}
589                 print(\textcolor{stringliteral}{'TEXT: '}, observations[valid\_inds[i]][\textcolor{stringliteral}{'text'}])
590                 print(\textcolor{stringliteral}{'PREDICTION: '}, curr\_pred, \textcolor{stringliteral}{'\(\backslash\)n~'})
591         \textcolor{keywordflow}{return}
592 
593 
\end{DoxyCode}
\mbox{\Hypertarget{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}\label{classparlai_1_1agents_1_1legacy__agents_1_1seq2seq_1_1utils__v0_1_1PaddingUtils_ae7f9ca3d9fd7dd823895a28af6cae34f}} 
\index{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}!pad\+\_\+text@{pad\+\_\+text}}
\index{pad\+\_\+text@{pad\+\_\+text}!parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils@{parlai\+::agents\+::legacy\+\_\+agents\+::seq2seq\+::utils\+\_\+v0\+::\+Padding\+Utils}}
\subsubsection{\texorpdfstring{pad\+\_\+text()}{pad\_text()}}
{\footnotesize\ttfamily def parlai.\+agents.\+legacy\+\_\+agents.\+seq2seq.\+utils\+\_\+v0.\+Padding\+Utils.\+pad\+\_\+text (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{observations,  }\item[{}]{dictionary,  }\item[{}]{end\+\_\+idx = {\ttfamily None},  }\item[{}]{null\+\_\+idx = {\ttfamily 0},  }\item[{}]{dq = {\ttfamily False},  }\item[{}]{eval\+\_\+labels = {\ttfamily True},  }\item[{}]{truncate = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}We check that examples are valid, pad with zeros, and sort by length so that we
can use the pack_padded function.

The list valid_inds
keeps track of which indices are valid and the order in which we sort
the examples.
dq -- whether we should use deque or list
eval_labels -- whether or not we want to consider eval labels
truncate -- truncate input and output lengths
\end{DoxyVerb}
 

Definition at line 430 of file utils\+\_\+v0.\+py.


\begin{DoxyCode}
430     ):
431         \textcolor{stringliteral}{"""}
432 \textcolor{stringliteral}{        We check that examples are valid, pad with zeros, and sort by length so that we}
433 \textcolor{stringliteral}{        can use the pack\_padded function.}
434 \textcolor{stringliteral}{}
435 \textcolor{stringliteral}{        The list valid\_inds}
436 \textcolor{stringliteral}{        keeps track of which indices are valid and the order in which we sort}
437 \textcolor{stringliteral}{        the examples.}
438 \textcolor{stringliteral}{        dq -- whether we should use deque or list}
439 \textcolor{stringliteral}{        eval\_labels -- whether or not we want to consider eval labels}
440 \textcolor{stringliteral}{        truncate -- truncate input and output lengths}
441 \textcolor{stringliteral}{        """}
442 
443         \textcolor{keyword}{def }valid(obs):
444             \textcolor{comment}{# check if this is an example our model should actually process}
445             \textcolor{keywordflow}{return} \textcolor{stringliteral}{'text'} \textcolor{keywordflow}{in} obs \textcolor{keywordflow}{and} len(obs[\textcolor{stringliteral}{'text'}]) > 0
446 
447         \textcolor{keywordflow}{try}:
448             \textcolor{comment}{# valid examples and their indices}
449             valid\_inds, exs = zip(
450                 *[(i, ex) \textcolor{keywordflow}{for} i, ex \textcolor{keywordflow}{in} enumerate(observations) \textcolor{keywordflow}{if} valid(ex)]
451             )
452         \textcolor{keywordflow}{except} ValueError:
453             \textcolor{comment}{# zero examples to process in this batch, so zip failed to unpack}
454             \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}
455 
456         \textcolor{comment}{# `x` text is already tokenized and truncated}
457         \textcolor{comment}{# sort by length so we can use pack\_padded}
458         \textcolor{keywordflow}{if} any([\textcolor{stringliteral}{'text2vec'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]):
459             parsed\_x = [ex[\textcolor{stringliteral}{'text2vec'}] \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
460         \textcolor{keywordflow}{else}:
461             parsed\_x = [dictionary.txt2vec(ex[\textcolor{stringliteral}{'text'}]) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
462 
463         \textcolor{keywordflow}{if} len(parsed\_x) > 0 \textcolor{keywordflow}{and} \textcolor{keywordflow}{not} isinstance(parsed\_x[0], deque):
464             \textcolor{keywordflow}{if} dq:
465                 parsed\_x = [deque(x, maxlen=truncate) \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
466             \textcolor{keywordflow}{elif} truncate \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} truncate > 0:
467                 parsed\_x = [x[-truncate:] \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
468 
469         x\_lens = [len(x) \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x]
470         ind\_sorted = sorted(range(len(x\_lens)), key=\textcolor{keyword}{lambda} k: -x\_lens[k])
471 
472         exs = [exs[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
473         valid\_inds = [valid\_inds[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
474         parsed\_x = [parsed\_x[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
475         end\_idxs = [x\_lens[k] \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} ind\_sorted]
476 
477         eval\_labels\_avail = any([\textcolor{stringliteral}{'eval\_labels'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs])
478         labels\_avail = any([\textcolor{stringliteral}{'labels'} \textcolor{keywordflow}{in} ex \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs])
479         \textcolor{keywordflow}{if} eval\_labels:
480             some\_labels\_avail = eval\_labels\_avail \textcolor{keywordflow}{or} labels\_avail
481         \textcolor{keywordflow}{else}:
482             some\_labels\_avail = labels\_avail
483 
484         max\_x\_len = max(x\_lens)
485 
486         \textcolor{comment}{# pad with zeros}
487         \textcolor{keywordflow}{if} dq:
488             parsed\_x = [
489                 x
490                 \textcolor{keywordflow}{if} len(x) == max\_x\_len
491                 \textcolor{keywordflow}{else} x + deque((null\_idx,)) * (max\_x\_len - len(x))
492                 \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x
493             ]
494         \textcolor{keywordflow}{else}:
495             parsed\_x = [
496                 x \textcolor{keywordflow}{if} len(x) == max\_x\_len \textcolor{keywordflow}{else} x + [null\_idx] * (max\_x\_len - len(x))
497                 \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} parsed\_x
498             ]
499         xs = parsed\_x
500 
501         \textcolor{comment}{# set up the target tensors}
502         ys = \textcolor{keywordtype}{None}
503         labels = \textcolor{keywordtype}{None}
504         y\_lens = \textcolor{keywordtype}{None}
505         \textcolor{keywordflow}{if} some\_labels\_avail:
506             \textcolor{comment}{# randomly select one of the labels to update on (if multiple)}
507             \textcolor{keywordflow}{if} labels\_avail:
508                 labels = [random.choice(ex.get(\textcolor{stringliteral}{'labels'}, [\textcolor{stringliteral}{''}])) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
509             \textcolor{keywordflow}{else}:
510                 labels = [random.choice(ex.get(\textcolor{stringliteral}{'eval\_labels'}, [\textcolor{stringliteral}{''}])) \textcolor{keywordflow}{for} ex \textcolor{keywordflow}{in} exs]
511             \textcolor{comment}{# parse each label and append END}
512             \textcolor{keywordflow}{if} dq:
513                 parsed\_y = [deque(maxlen=truncate) \textcolor{keywordflow}{for} \_ \textcolor{keywordflow}{in} labels]
514                 \textcolor{keywordflow}{for} deq, y \textcolor{keywordflow}{in} zip(parsed\_y, labels):
515                     deq.extendleft(reversed(dictionary.txt2vec(y)))
516             \textcolor{keywordflow}{else}:
517                 parsed\_y = [dictionary.txt2vec(label) \textcolor{keywordflow}{for} label \textcolor{keywordflow}{in} labels]
518             \textcolor{keywordflow}{if} end\_idx \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
519                 \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y:
520                     y.append(end\_idx)
521 
522             y\_lens = [len(y) \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y]
523             max\_y\_len = max(y\_lens)
524 
525             \textcolor{keywordflow}{if} dq:
526                 parsed\_y = [
527                     y
528                     \textcolor{keywordflow}{if} len(y) == max\_y\_len
529                     \textcolor{keywordflow}{else} y + deque((null\_idx,)) * (max\_y\_len - len(y))
530                     \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y
531                 ]
532             \textcolor{keywordflow}{else}:
533                 parsed\_y = [
534                     y \textcolor{keywordflow}{if} len(y) == max\_y\_len \textcolor{keywordflow}{else} y + [null\_idx] * (max\_y\_len - len(y))
535                     \textcolor{keywordflow}{for} y \textcolor{keywordflow}{in} parsed\_y
536                 ]
537             ys = parsed\_y
538 
539         \textcolor{keywordflow}{return} xs, ys, labels, valid\_inds, end\_idxs, y\_lens
540 
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
parlai/agents/legacy\+\_\+agents/seq2seq/\hyperlink{utils__v0_8py}{utils\+\_\+v0.\+py}\end{DoxyCompactItemize}
